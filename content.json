{"meta":{"title":"C","subtitle":"小陈の博客","description":"博客因兴趣诞生,在不断完善中","author":"小陈","url":"https://tangtangchen.github.io"},"pages":[{"title":"关于本站","date":"2021-09-20T04:58:56.000Z","updated":"2022-10-24T13:01:41.997Z","comments":false,"path":"about/index.html","permalink":"https://tangtangchen.github.io/about/index.html","excerpt":"","text":"仙气の云彩“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：仙气のchen QQ：857535276 （嘀嘀~，麻烦让一下，我要开车了！） 座右铭：既然选择了远方 便只顾风雨兼程"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://tangtangchen.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://tangtangchen.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://tangtangchen.github.io/comments/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://tangtangchen.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://tangtangchen.github.io/tags/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://tangtangchen.github.io/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-10-24T09:47:33.307Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://tangtangchen.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"https://tangtangchen.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-07-26T07:32:21.052Z","comments":false,"path":"List/music/index.html","permalink":"https://tangtangchen.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://tangtangchen.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://tangtangchen.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"并发编程","slug":"05-并发","date":"2022-12-24T13:00:00.000Z","updated":"2023-08-22T06:01:15.493Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://tangtangchen.github.io/posts/5.html","excerpt":"","text":"Java并发并发编程的三个基本概念原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行； 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值； 有序性：即程序执行的顺序按照代码的先后顺序执行。 线程线程跟进程线程是进程划分成的更小的运行单位； 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位； 一个进程中可以有多个线程，多个线程共享进程中的堆和方法区；线程私有自己的程序计数器、虚拟机栈和本地方法栈； 线程执行开销小，但不利于资源的管理和保护；而进程正相反。 线程私有程序计数器为什么是私有的线程切换后能恢复到正确的执行位置 虚拟机栈和本地方法栈为什么是私有的为了保证线程的局部变量不被其他线程访问到 使用多线程充分利用多核CPU的性能，提升系统的性能 线程的生命周期和六种状态线程的生命周期中并不是固定处于某个状态，而是随着代码的执行在不同状态之间切换。 new：初始状态，线程被创建出来但是没有被调用start（）； runnable：运行状态，线程被调用start（）等待被运行； blocked：阻塞状态，等待锁释放； waiting：等待状态，线程需要其他线程做出一些特定动作（通知或中断） time_waiting：超时等待状态，可以在指定时间后自行返回，而非waiting那样一直等待； terminated：终止状态，表示该线程已经运行完毕； 新建状态（NEW）： 当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值 就绪状态（RUNNABLE）： 当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。 运行状态（RUNNING）： 如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。 阻塞状态（BLOCKED）： 阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。 直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状 态。阻塞的情况分三种： 等待阻塞（o.wait-&gt;等待对列）： 运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue) 中。 同步阻塞（lock-&gt;锁池）： 运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线 程放入锁池(lock pool)中。 其他阻塞(sleep/join）： 运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时， JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态。 线程死亡（DEAD）： 线程会以下面三种方式结束，结束后就是死亡状态。 正常结束 run()或 call()方法执行完成，线程正常结束。 异常结束 线程抛出一个未捕获的 Exception 或 Error。 调用 stop 3. 直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用 终止线程4种方式 正常运行结束 程序运行结束，线程自动结束。 使用退出标志退出线程 一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的 运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环 Interrupt 方法结束线程 使用 interrupt()方法来中断线程有两种情况： 1、线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时， 会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的，一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。 2、线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用 interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。 stop 方法终止线程（线程不安全） 程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关 闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是： thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子 线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用 thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈 现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因 此，并不推荐使用 stop 方法来终止线程。 sleep 与 wait 区别 对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于 Object 类中的。 sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 在调用 sleep()方法的过程中，线程不会释放对象锁。 而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 线程基本方法wait、sleep、notify、notifyAll、join、yield等 wait：线程等待 调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait（）方法后，会释放对象的锁。因此，wait方法一般用在同步方法或同步代码块中。 sleep：线程睡眠 sleep导致当前线程休眠，与wait方法不同的是sleep不会释放当前占有的锁，sleep（long）会导致线程进入TIMEED-WAITING状态 yield：线程让步 yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片。 interrupt：线程中断 中断一个线程，本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态（如阻塞，终止等） 调用interrupt（）方法并不会中断一个正在运行的线程。也就是说处于Running状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标记位而已。 若调用sleep（）而使线程处于TIMED-WAITING状态，这是调用interrupt（）方法，会抛出InterruptedException，从而使线程提前结束TIMED-WAITING状态。 许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。 中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止 一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以 根据 thread.isInterrupted()的值来优雅的终止线程。 Join ：等待其他线程终止 join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，直到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。 notify：线程唤醒 Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象 上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调 用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继 续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞 争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。 其他方法： sleep()：强迫一个线程睡眠Ｎ毫秒。 isAlive()： 判断一个线程是否存活。 join()： 等待线程终止。 activeCount()： 程序中活跃的线程数。 enumerate()： 枚举程序中的线程。 currentThread()： 得到当前线程。 isDaemon()： 一个线程是否为守护线程。 setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线 程依赖于主线程结束而结束) setName()： 为线程设置一个名称。 wait()： 强迫一个线程等待。 notify()： 通知一个线程继续运行。 setPriority()： 设置一个线程的优先级。 getPriority():：获得一个线程的优先级。 线程上下文切换假如发生某些情况时（让出CPU、时间片用完、中断），线程切换（保存当前线程上下文，留待下次占用CPU时恢复现场，加载下个占用CPU的线程上下文）。 巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存 下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做 上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。 上下文 是指某一时间点 CPU 寄存器和程序计数器的内容 Java锁乐观锁（多读场景，竞争较少）：每次假设最好的情况，认为共享资源每次访问不会出问题，每次去拿数据的时候都认为别人不会修改，所以不会上锁，仅在修改更新的时候去会判断一下在此期间别人有没有去更新这个数 据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新）， 如果失败则要重复读-比较-写的操作。 不存在锁竞争，不会有死锁发生，但如果冲突频繁发生，会频繁的失败与重试，导致CPU飙升。 乐观锁一般会使用版本号机制或 CAS 算法实现（CAS 的全称是 Compare And Swap（比较与交换））。 乐观锁存在的问题： ABA问题、循环时间长开销大、只能保证一个共享变量的循环操作 ABA解决方法ABA问题就是变量V在初次读取时值为A，准备赋值时读取仍然为A，但是这并不代表中间并没有被改变过。 在变量前面加上时间戳或版本号 悲观锁（多写场景，竞争激烈）：每次假设最坏的情况，每次去拿数据的时候都认为别人 会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程） Java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。 激烈的锁竞争会导致频繁的系统上下文切换，造成系统的性能开销，悲观锁可能会存在死锁问题； 自旋锁如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁 的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋）， 等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程 也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。 在 1.6 引入了适应性自旋锁，适应 性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥 有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间 Synchronized 同步锁synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。 Synchronized 核心组件 Wait Set:那些调用wait方法的线程被放置在这里 Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中 Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中； OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为OnDeck Owner：当前已经获取所有资源的线程被称为Owner ！Onwer：当前释放锁的线程 ReentrantLockReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。 1、ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。 ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock Semaphore 信号量Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池 实现互斥锁（计数器为 1） 我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量， 表示两种互斥状态。 Semaphore 与 ReentrantLockSemaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与 release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被 Thread.interrupt()方法中断。 此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock 不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。 Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而 无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成 AtomicInteger首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有 AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同， 区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference将一个对象的所 有操作转化成原子操作。 我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。 通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些 同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger 的性能是 ReentantLock 的好几倍。 ReadWriteLock 读写锁为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如 果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。 读锁 如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 写锁 如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上 读锁，写的时候上写锁！ ava 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现 ReentrantReadWriteLock。 共享锁和独占锁java 并发包提供的加锁模式分为独占锁和共享锁。 独占锁 独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。 独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 共享锁 共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 分段锁分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践 预防和避免死锁预防死锁： ​ 破环请求与保持条件； ​ 破环不剥夺条件； ​ 破环循环等待条件； 避免死锁： ​ 资源分配是使用-银行家算法； synchronized 关键字https://zhuanlan.zhihu.com/p/377423211 synchronized 工作原理synchronized是一个同步关键字，在多线程场景下，作用于代码同步保护数据共享安全。 synchronized 关键字的使用方式主要有下面 3 种： 修饰普通同步方法：锁对象就是当前实例 修饰静态同步方法：锁对象是当前类的Class字节码对象 修饰同步代码块：锁对象是synchronized后面括号里配置的对象，可以是某个对象，也可以是某个类的.class对象。 JVM对于同步方法和同步代码块的处理方式不同，对于同步方法，JVM采用ACC_SYNCHRONIZED标记符来实现同步，而对于同步代码块，JVM则采用 monitorenter（加锁）和monitorexit （释放锁）这两个指令实现同步。 Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是monitorenter和 monitorexit 指令实现的，而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法。 反汇编语言中有两个monitorexit 是为了执行异常的monitorenter指令。而字节码中多出的monitorexit指令，就是异常结束时，被执行用来释放monitor的。 synchronized特性原子性 原子性指的是在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行。 如何保证： Java内存模型中提供了字节码指令monitorenter和monitorexit 来隐式的使用这两个操作，在synchronized块之间的操作都是具备原子性的。 可见性 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 如何保证： 通过内存屏障。内存屏障按照可见性分为：load屏障和Store屏障 load屏障：执行refresh，从其他处理器的高速缓存、主内存，加载数据到自己的高速缓存，保证数据的最新。 Store屏障：执行flush操作，自己处理器更新的变量值，刷新到高速缓存、主内存中。 被synchronized修饰的代码，在开始执行时被加锁，执行完毕后解锁，在解锁一个变量之前，必须先把此变量同步回主存，这样解锁以后，其他线程就可以访问到被修改后的值，从而保证可见性。 有序性 程序执行的顺序按照代码的先后顺序执行。 通过内存屏障。内存屏障按照有序性分为：Acquire屏障和Release屏障 Acquire屏障：load屏障之后，加Acquire屏障。它会禁止同步代码块内的读操作，和外面的读写操作发生指令重排； Release屏障：禁止写操作，和外面的读写操作发生指令重排； 在 monitorenter 指令和 Load 屏障之后，会加一个 Acquire屏障，这个屏障的作用是禁止同步代码块里面的读操作和外面的读写操作之间发生指令重排，在 monitorexit 指令前加一个Release屏障，也是禁止同步代码块里面的写操作和外面的读写操作之间发生重排序。 int a = 0; synchronize (this){ //monitorenter // Load内存屏障 // Acquire屏障，禁止代码块内部的读，和外面的读写发生指令重排 int b = a; a = 10; //注意：内部还是会发生指令重排 // Release屏障，禁止写，和外面的读写发生指令重排 } //monitorexit //Store内存屏障 as-if-serial，synchronized 的有序性，不是 volatile 的防止指令重排序。 可重入性 可重入指的就是一个线程可以多次执行synchronized，重复获取同一把锁。 synchronized关键字可以实现什么类型的锁？ 悲观锁：synchronized关键字实现的是悲观锁，每次访问共享资源时都会上锁。 非公平锁：synchronized关键字实现的是非公平锁，即线程获取锁的顺序并不一定是按照线程阻塞的顺序。 可重入锁：synchronized关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。 独占锁或者排他锁：synchronized关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。 Synchronzied锁升级在jdk1.6之前，synchronized被称为重量级锁，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁和轻量级锁。 无锁-&gt;偏向锁（单线程）-&gt;轻量级锁（CAS自旋）-&gt;重量级锁（阻塞） 为什么要进行锁优化呢 JDK1.6之前是通过重量级锁方式去实现线程之间锁竞争的，重量级锁底层依赖操作系统的Mutex Lock来去实现互斥锁的一个功能 。Mutex是系统方法，由于权限隔离的关系，应用程序调用系统方法需要用户态切换到内核状态执行，带来性能上的损耗。 因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的Mutex Lock来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大 引入偏向锁的目的 减少只有一个线程执行同步代码块时的性能消耗，即在没有其他线程竞争的情况下，一个线程获得了锁。 偏向锁的获取流程： 检查对象头中Mark Word是否为可偏向状态，如果不是则直接升级为轻量级锁。 如果是，判断Mark Work中的线程ID是否指向当前线程，如果是，则执行同步代码块。 如果不是，则进行CAS操作竞争锁，如果竞争到锁，则将Mark Work中的线程ID设为当前线程ID，执行同步代码块。 如果竞争失败，升级为轻量级锁。 偏向锁原理：使用CAS操作将当前线程的ID记录到对象的Mark Word中。 引入轻量级锁的目的：在多线程交替执行同步代码块时（未发生竞争），避免使用互斥量（重量锁）带来的性能消耗。但多个线程同时进入临界区（发生竞争）则会使得轻量级锁膨胀为重量级锁。 重量级锁的底部实现原理：Monitor 在JDK1.6版本之后Synchronized增加锁升级的机制，来平衡数据安全性和性能的关系。简单来说，线程去访问Synchronized同步代码块的时候，Synchronized先去尝试在不加重量级锁的情况去保证线程安全性，引入了偏向锁和轻量级锁，偏向锁就是直接把当前锁偏向于某个线程，通过CAS机制来修改偏向锁的一个标记（Mark word中的线程ID改为当场线程ID），该锁适合同一线程多次去访问同一个锁资源的情况，并且没有其他线程竞争的一个场景中。轻量级锁又可以称为自旋锁，基于自适应自旋的机制，通过多次自旋去重试竞争锁（自旋次数过多就会升级到重量级锁），自旋锁的优点在于，避免了用户态到内核态切换带来的性能损耗。 锁消除锁消除是指Java虚拟机在即时编译时，通过对运行上下的扫描，消除那些不可能存在共享资源竞争的锁。锁消除可以节约无意义的请求锁时间。 锁粗化如果虚拟机检测到有一系列操作都是对某个对象反复加锁和解锁，会将加锁同步的范围粗化到整个操作序列的外部。 经典案例。 for(int i=0;i&lt;n;i++){ synchronized(lock){ } } 这段代码会导致频繁地加锁和解锁，锁粗化后 synchronized(lock){ for(int i=0;i&lt;n;i++){ } } synchronized和volatile的区别 volatile主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。synchronized主要是解决多个线程访问资源的同步性。 volatile作用于变量，synchronized作用于代码块或者方法。 volatile仅可以保证数据的可见性，不能保证数据的原子性。synchronized可以保证数据的可见性和原子性。 volatile不会造成线程的阻塞，synchronized会造成线程的阻塞。 volatile关键字volatile关键字是否保证可见性和原子性的原理volatile关键字保证数据的可见性，无法保证数据的原子性； 将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取； volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized，volatile更轻量级； volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序 ReentrantLockReentrantLock实现了Lock接口，是一个可重入且独占式锁（可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁）。和synchronized关键字类似，而且更强大、更灵活，增加了轮询、超时、中断、公平锁、非公平锁等功能。 ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。 ReentrantLock 的底层就是由 AQS 来实现的。 公平锁和非公平锁公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。 ReentrantLock和synchronized区别 二者都是可重入锁 ReentrantLock依赖JDK（API）实现，synchronized依赖JVM实现 前者功能更加强大 前者实现了公平锁，后者只有非公平锁 前者实现了可中断锁，后者无 可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。 AQSAQS就是一个抽象类，主要用来构建锁和同步器，为锁和同步器提供一些实现。 AQS原理如果被请求的共享资源空闲，那么将这个请求线程作为工作线程，将共享资源设为独占资源。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制就是AQS基于CLH锁实现的。 CLH锁：是对自旋锁的一种改进，是一个虚拟的双向队列，暂时获得不到锁的线程会加入到该队列中。 AQS两种资源共享方式 Exclusive。（独占，只有一个线程能执行，如ReentrantLock） Share。（共享，多个线程同时执行，如Semaphore/CountDownLatch） 同时实现两种资源共享方式的，如ReentrantReadWriteLock。 基于AQS的常见同步类Semaphore（信号量） Semaphore(信号量)可以用来控制同时访问特定资源的线程数量。 CountDownLatch （倒计时器） CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。 CyclicBarrier(循环栅栏) 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 ThreadLocalThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 创建线程 继承Thread类：自己的类没有继承类就可以通过继承Thread类创建线程，Thread类本质上是实现了Runnable接口的一个实例。启动线程的唯一方法是通过Thread类的start（）方法，start（）方法是一个native方法，它启动线程并执行run（）方法。 实现Runnable接口：当自己的类已经继承了另一个类，就无法直接继承Thread类，此时可以通过实现Runnable接口方式创建线程。首先先需要实例化Thread，将自己的MyThread实例传入 实现Callable接口：有返回值的任务必须实现Callable接口，并可以抛出异常，无返回值的任务必须实现Runnable接口。执行Callable任务后可以获得一个Future对象，该对象上调用get就可以得到Callable任务返回的Object，再结合线程池接口ExecutorService就可以实现有返回结果的多线程。 线程池方式创建：为了避免重复创建销毁，采用此方式。Java提供了构建线程池的方式（Executors类） 注：继承Thread实际上就是实现Runable， 线程池创建线程池 通过ThreadPoolExecutor构造函数创建（推荐手动创建线程池） 通过Executor框架的工具类Executors来创建（规范中不推荐这种方式去创建线程池，因为这种方式对线程的控制粒度比较低，导致OOM） JDK基于Executors提供的5种线程池 newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。（单例线程池） newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。（定长线程池） newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 （缓存线程池，没有核心线程） newWorkStealingPool：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。（工作窃取线程池） newScheduleThreadPool：（定时任务线程池，每个线程都有自己的阻塞队列，当自己的阻塞队列满了时，会去其他线程的阻塞队列窃取） 线程池的七个参数手动创建线程池，要对线程池的七个参数有所了解 corePoolSize：核心线程数 maximumPoolSize：最大线程数 keepAliveTime：最大空闲时间 空闲时间内没有新任务，此 线程资源会释放 unit： 时间单位 空闲时间单位，如秒、毫秒等 workQueue：阻塞队列 当核心线程都在运行时，来任务就加入到其中 ThreadFactoty：线程工厂 给线程指定名称，当线程出现问题时，可以直接锁定发生位置 handler ：拒绝策略： 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝 策略 核心参数该如何设置线程池的饱和（拒绝）策略 AbortPolicy：直接丢弃任务，抛出异常，这是默认策略 CallerRunsPolicy：只用调用者所在的线程来处理任务 DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务 DiscardPolicy：直接丢弃任务，也不抛出异常 线程池状态线程池的核心属性就是ctl，基于ctl拿到线程池的状态以及工作线程的个数 ctl实际上是一个32位的int类型，高三位为线程池状态，低29位是工作线程个数 五个状态： 111：RUNNING状态，RUNNING 可以处理任务，并且处理阻塞队列中的任务 000：SHUTDOWN状态，不会接收新任务，正在处理的任务正常进行，阻塞队列的任务也会做完 001：STOP状态，不会接受新任务，正在处理任务的线程会被中断，阻塞队列的任务一个不管 010：TIDYING状态，这个状态是SHUTDOWN或者STOP转换过来的，代表当前线程池马上关闭，就是过渡状态 011：TERMINATED状态，这个状态是TIDYING状态转换过来的，转换过来只需要执行一个terminated方法。 其中正在处理任务的线程会被中断，不一定保证中断，看任务逻辑中是否有线程中断标记位的出口，有则中断 线程池为何要构建空任务的非核心线程核心线程为0，阻塞队列有任务，导致任务饥饿 导致这种情况发生有两种： 创建线程池时设置核心线程数量为0 核心线程默认是不可以超时的，但是可以修改属性allowCoreThreadTimeOut为true，可以超时 线程池处理任务流程 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。 线程池核线程数配置分为CPU密集型和IO密集型 CPU密集型： N（CPU 核心数）+1 IO密集型：CPU核心数量*2。 Future类Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。 核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。 Executor框架Java5引进的，通过Executor来启动线程比Thread的start方法更好。更易管理，效率更好（用线程池实现），关键：有助于避免this逃避问题。 this逃避问题：指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。 Executor框架组成： 任务：实现Runable和callable接口 任务的执行：Executor 异步计算的结果：Future Java常见并发容器ConcurrentHashMap：线程安全的 HashMap。 CopyOnWriteArrayList : 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector。 ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。 BlockingQueue : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。 ConcurrentSkipListMap: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tangtangchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://tangtangchen.github.io/tags/%E6%83%B3%E6%B3%95/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://tangtangchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java集合","slug":"03-Java集合","date":"2022-12-02T13:00:00.000Z","updated":"2023-08-22T05:59:58.311Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://tangtangchen.github.io/posts/3.html","excerpt":"","text":"Java集合 List，Set ，Queue；MapList（对付顺序）：存储元素是有序的、可重复的； ​ 底层数据结构 ​ ArrayList：Object【】数组 （线程不安全） ​ Vector：Object【】数组 （线程安全，使用synchronized 关键字；Vector和Stack已经被淘汰，推荐使用并发集合类（例如ConcurrentHashMap、CopyOnWriteArrayList） ​ LinkedList：双向链表 （线程不安全） Set（注重独一无二的性质）：存储元素是无序的、不可重复的； ​ 底层数据结构 ​ HashSet（无序、唯一）：基于HashMap实现，哈希表 （线程不安全） ​ LinkedHashSet：是HashSet的子类，内部通过LinkHashMap实现，链表+哈希表 （线程不安全） ​ TreeSet（有序、唯一）：红黑树 （线程不安全） Queue（实现排队功能的叫号机）：先确定前后顺序，存储的元素有序、不可替代； ​ 底层数据结构 ​ PriorityQueue：Obeject【】数组实现二叉堆 ​ ArrayQueue：Object【】 数组 + 双指针 Map（用key来搜索）：使用键值对存储，key是无序的、不可重复的，value是无序的、可重复的； ​ 底层数据结构 ​ HashMap：数据+链表——（解决哈希冲突方法变化）—–》数组+链表/红黑树 （线程不安全） ​ LinkedHashMap：继承HashMap, 数组+链表/红黑树 （线程不安全） ​ TreeMap：红黑树 (线程不安全) ​ Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的，经过了synchronized的修饰 （线程安全） HashMap扩容原理HashMap默认的初始化大小为16，之后每次扩容，容量会变为原来的2倍。创建时如果给定了容量初始值，hashmap会将其扩容到2的幂次方大小； 必须为2的幂次方原因因为在hashMap的length等于2的n次方的时候，才会有(取模运算优化)hash%length==hash&amp;(length-1)，哈希算法的目的是为了加快哈希计算以及减少哈希冲突，所以此时&amp;操作更合适，所以在length等于2的幂次方的时候，可以使用&amp;操作加快操作且减少冲突，所以hashMap长度是2的幂次方 HashMap的负载因子为何默认是0.75负载因子是0.75的时，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率； HashMap/Hashtable的键值是否能为nullHashMap可以，但Hashtable不行。会报NPE（空指针异常）。 所以集合转Map时，一定要注意value值为null时会报NPE异常。 链表超过8变成红黑树【链表超过8变成红黑树，那红黑树转化为链表的话阈值还是8吗？】 当链表长度大于8的时候，如果当前数组的长度小于64，那么先进行数组扩容；大于64时，转换为红黑树； 数组、链表、红黑树【数组、链表、红黑树什么情况下会有共存的状态？共存在的话是几种？三种可以同时存在一个hashmap里是吧？】 ConcurrentHashMap采用 Node + CAS + synchronized 来保证并发安全。数据结构跟 HashMap 1.8 的结构类似，数组+链表/红黑二叉树，Node 只能用于链表的情况，红黑树的情况需要使用 **TreeNode**。当冲突链表达到一定长度时，链表会转换成红黑树。 集合转换集合转Map使用Collectors类的toMap（）方法","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tangtangchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://tangtangchen.github.io/tags/%E6%83%B3%E6%B3%95/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://tangtangchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java基础","slug":"02-Java基础","date":"2022-11-06T13:00:00.000Z","updated":"2023-08-22T05:59:44.398Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://tangtangchen.github.io/posts/2.html","excerpt":"","text":"Java基础Java中int跟Integer的区别int是基本数据类型，Integer则是包装类型；后者可以用于泛型； 前者有默认值且不是null，后者不赋值就是null； 比较方式不同，对于基本数据类型来说，“==”比较的是值，而对于包装数据类型 “ ==”比较的是对象的内存地址。 基本类型 位数 字节 默认值 int 32 4 0 short 16 2 0 long 64 8 0L byte 8 1 0 char 16 2 ‘u0000’ float 32 4 0f double 64 8 0d boolean 1 false 包装类型的常量池技术字符串的创建耗费大量的时间和空间，频繁创建字符串影响程序性能。创建字符串时，首先会判断字符串常量池是否有该字符串，如果有直接引用，没有才会实例化字符串，并放入常量池。（包装类默认创建的缓存数据只适用与[-128.127]这个范围，若超出任然会去创建新的对象） 有包装类型的原因：包装类型可以用于泛型，基本数据类型不行 包装类型的缓存机制:Byte、Integer、Short、Long这四种包装类型默认创建了数值【-128，127】的相应类型的缓存数据， Character创建了数值在【0，127】范围的缓存数据， Boolean直接返回TrueorFalse， 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制 自动拆装箱基本类型与包装类型的互换； 装箱就是用了包装类的valueOf（）方法；拆箱就是调用了xxxValue（）方法； Integer i = 10 等价于 Integer i = Integer.valueOf(10) int n = i 等价于 int n = i.intValue(); 自动拆箱引发的 NPE（空指针异常） 问题数据库查询为null，自动拆箱，用基本数据类型接受有NPE风险； 使用三目运算符不当会导致NPE异常； ==跟equals的区别对于基本数据类型，==比较的是值，对于引用数据类型， ==比较的是对象的内存地址，eqials比较的是内容； equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象： 情况1，类没有重写equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。（如Object类没有重写，String类重写了） 情况2，类重写了equals()方法。一般，我们都重写equals()方法来比较两个对象的内容是否相等； String、StringBuffer、StringBuilder 的区别线程安全：String、StringBuffer 线程不安全：StringBuilder 可变性：StringBuffer、StringBuilder 不可变： String （String类中使用final关键字修饰字符数组来保存字符串，所以String对象不可变） 性能：StringBuilder&gt;StringBuffer&gt;String (String类改变都会生成一个新的对象，而StringBuffer每次都对 对象 本身进行操作) String 真正不可变有下面几点原因： 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。 （直接修改，其实它们已经是指向了一个新的对象） String类为什么设置成不可变的设置成不可变的总共有四个好处： 1.字符串常量池的实现 通过字符串常量池，我们就可以节约大量的内存空间。如果不设置为不可变，字符串不可复用。 2.用作HashMap的key String是不可变的可以很方便的用作HashMap的key； 对于HashMap的工作原理是哈希函数，会通过哈希函数计算的值去找到对于的value，如果String为可变的，改变其值之后，哈希值就变化了，会找不到对应的value。 3.用于缓存HashCode 4.线程安全 不可变的对象一定是线程安全的，可以安全的被多个线程共享。 字符串拼接用“+” 还是 StringBuilder在JDK9之前，每次使用“+”号相当于自动创建了 StringBuilder进行拼接，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。。但是这种使用在循环中不合适，每次循环都会创建一个 StringBuilder对象，影响性能。 在JDK9之后，“+”改用动态方法makeConcatWithConstants（）实现，而不是大量的 StringBuilder。 重载和重写重载： 发生在同一个类中（或者父类和子类之间），方法名相同，参数类型不同、个数不同、顺序不同、方法返回值和访问修饰符可以不同。 （重载就是同一个类多个同名方法根据不同的传参来执行不同的逻辑处理） 重写： 重写发生在运行期间，是子类对父类的允许访问的方法的实现过程进行重新编写。（外部样子不能改变，内部逻辑可以改变） 构造器（constructor）是否可被重写（override）构造器不能被继承，所以不能被重写，但是可以被重载； 每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须一开始调用父类的构造函数。 接口和抽象类有什么不同接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。 浅拷贝和深拷贝（对象拷贝） 上图为引用拷贝，不属于浅拷贝和深拷贝，两个变量此时指向同一个对象，任意一个变量操作了对象的属性，都会发生改变。 浅拷贝： 两个变量指向不同的对象，各自改变自己的属性，不影响另一个对象。但如果拷贝的对象中有属性属于引用数据类型，浅拷贝则仅负责引用数据类型的引用地址。 深拷贝： Object 类的常见方法clone（）：拷贝一份对象； wait（）：等待一份线程； hashCode（）：返回对象的哈希值； getclass（）：获得当前对象的class对象； equals（）：object类没有重写，与==相同；String类重写，比较引用对象的值； notify（）：唤醒一份线程； finalize（）：实例被垃圾回收的时候触发； Java 异常类层次结构图 Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。 Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。 Java 反射反射有什么优点/缺点通过反射可以获取任意一个类的所有属性和方法，还可以调用这些属性和方法。 优点：可以让代码变得更加灵活，为各种框架提供开箱即用的功能提供了便利 缺点：让我们在运行时有了分析操作类的能力，同时也增加了安全问题，例如可以无视泛型参数的安全检查。 框架中大量使用了动态代理，而动态代理的实现也依赖反射。 获得class对象的方式 通过 Class.forName()传入类的全路径获取 通过对象实例instance.getClass()获取 通过类加载器xxxClassLoader.loadClass()传入类路径获取 Java 泛型泛型的作用泛型是JDK5引入的新特性。 编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。 泛型使用方式：泛型类、泛型接口、泛型方法。 泛型类型擦除类型擦除：Java的泛型是伪泛型，因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说的类型擦除。 泛型本质上其实还是编译器的行为，为了保证引入泛型机制但不创建新的类型，减少虚拟机的运行开销，编译器通过擦除将泛型类转化为一般类。 既然编译器要把泛型擦除，那为什么还要用泛型呢？用 Object 代替不行吗？ ● 使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。 ● 泛型可以使用自限定类型如 T extends Comparable 。 泛型有哪些限制无边界的通配符：**&lt;?&gt;** 固定上边界的通配符：**&lt;? extends E&gt;** 固定下边界的通配符： &lt;? super E&gt; 通配符通配符 ？和泛型 T 区别 T 可以用于声明变量或常量而 ? 不行。 T 一般用于声明泛型类或方法，通配符 ? 一般用于泛型方法的调用代码和形参。 T 在编译期会被擦除为限定类型或 Object，通配符用于捕获具体类型。 ? extends xxx 和 ? super xxx 有什么区别?两者接收参数的范围不同。并且，使用 ? extends xxx 声明的泛型参数只能调用 get() 方法返回 xxx 类型，调用 set() 报 错。使用 ? super xxx 声明的泛型参数只能调用 set() 方法接收 xxx 类型，调用 get() 报错。 序列化/反序列化序列化：将数据结构或对象转换成二进制字节流的过程。 反序列化：将序列化过程中产生的二进制字节流转化为数据结构或对象的过程。 序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。 序列化和反序列化应用场景： 对象进行网络传输之前进行序列化，接受到序列化对象之后进行反序列化； 对象存储到文件之前需要进行序列化，将对象从文件中取出需要进行反序列化； 对象存储到数据库（Redis）之前需要进行序列化，从数据库中取出对象现需要进行反序列化； 将对象存储到内存中之前需要进行序列化，从内存中取出对象需要进行反序列化。 不想进行序列化的变量，使用 transient 关键字修饰。 Java常见语法糖Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。 Java 中的 for-each 就是一个常用的语法糖。 BigDecimal大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。 ​ 浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。BigDecimal的等值比较应使用compareTo（）方法。 内部类/匿名内部类 内部类就是类种类，依附于普通类中，可以间接实现Java类的多继承。 Java常见运行时异常ArrayStoreException：由于数组存储空间不够引起的异常； NullPointerException：空指针异常，程序试图访问一个空的数组中的元素或访问空的对象中的方法或变量时产生异常； IndexOutOfBoundsException：索引越界异常，由于数组下标越界或字符串访问越界引起异常； ClassCastException：类型转换异常，当把一个对象归为某个类，但实际上此对象并不是由这个类创建的，也不是其子类创建的，则会引起异常； NoSuchElementException：找不到元素异常； ArithmeticException：算数运算异常，由于除数为0引起的异常；","categories":[{"name":"Java","slug":"Java","permalink":"https://tangtangchen.github.io/categories/Java/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://tangtangchen.github.io/tags/%E6%83%B3%E6%B3%95/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://tangtangchen.github.io/categories/Java/"}]},{"title":"线程池","slug":"04-线程池","date":"2022-10-26T06:00:00.000Z","updated":"2023-08-22T06:00:31.510Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://tangtangchen.github.io/posts/4.html","excerpt":"","text":"线程池一、什么是线程池为什么要使用线程池 在开发中，为了提升效率的操作，我们需要将一些业务采用多线程的方式去执行。 比如有一个比较大的任务，可以将任务分成几块，分别交给几个线程去执行，最终做一个汇总就可以了。 比如做业务操作时，需要发送短信或者是发送邮件，这种操作也可以基于异步的方式完成，这种异步的方式，其实就是再构建一个线程去执行。 但是，如果每次异步操作或者多线程操作都需要新创建一个线程，使用完毕后，线程再被销毁，这样的话，对系统造成一些额外的开销。在处理过程中到底由多线程处理了多少个任务，以及每个线程的开销无法统计和管理。 所以咱们需要一个线程池机制来管理这些内容。线程池的概念和连接池类似，都是在一个Java的集合中存储大量的线程对象，每次需要执行异步操作或者多线程操作时，不需要重新创建线程，直接从集合中拿到线程对象直接执行方法就可以了。 JDK中就提供了线程池的类。 在线程池构建初期，可以将任务提交到线程池中。会根据一定的机制来异步执行这个任务。 可能任务直接被执行 任务可以暂时被存储起来了。等到有空闲线程再来处理。 任务也可能被拒绝，无法被执行。 JDK提供的线程池中记录了每个线程处理了多少个任务，以及整个线程池处理了多少个任务。同时还可以针对任务执行前后做一些勾子函数的实现。可以在任务执行前后做一些日志信息，这样可以多记录信息方便后面统计线程池执行任务时的一些内容参数等等…… 二、JDK自带的构建线程池的方式JDK中基于Executors提供了很多种线程池 2.1 newFixedThreadPool这个线程池的特别是线程数是固定的。 在Executors中第一个方法就是构建newFixedThreadPool public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } 构建时，需要给newFixedThreadPool方法提供一个nThreads的属性，而这个属性其实就是当前线程池中线程的个数。当前线程池的本质其实就是使用ThreadPoolExecutor。 构建好当前线程池后，线程个数已经固定好（线程是懒加载，在构建之初，线程并没有构建出来，而是随着人任务的提交才会将线程在线程池中国构建出来）。如果线程没构建，线程会待着任务执行被创建和执行。如果线程都已经构建好了，此时任务会被放到LinkedBlockingQueue无界队列中存放，等待线程从LinkedBlockingQueue中去take出任务，然后执行。 测试功能效果 public static void main(String[] args) throws Exception { ExecutorService threadPool = Executors.newFixedThreadPool(3); threadPool.execute(() -&gt; { System.out.println(\"1号任务：\" + Thread.currentThread().getName() + System.currentTimeMillis()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } }); threadPool.execute(() -&gt; { System.out.println(\"2号任务：\" + Thread.currentThread().getName() + System.currentTimeMillis()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } }); threadPool.execute(() -&gt; { System.out.println(\"3号任务：\" + Thread.currentThread().getName() + System.currentTimeMillis()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } }); } 2.2 newSingleThreadExecutor这个线程池看名字就知道是单例线程池，线程池中只有一个工作线程在处理任务 如果业务涉及到顺序消费，可以采用newSingleThreadExecutor // 当前这里就是构建单例线程池的方式 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService // 在内部依然是构建了ThreadPoolExecutor，设置的线程个数为1 // 当任务投递过来后，第一个任务会被工作线程处理，后续的任务会被扔到阻塞队列中 // 投递到阻塞队列中任务的顺序，就是工作线程处理的顺序 // 当前这种线程池可以用作顺序处理的一些业务中 (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } static class FinalizableDelegatedExecutorService extends DelegatedExecutorService { // 线程池的使用没有区别，跟正常的ThreadPoolExecutor没区别 FinalizableDelegatedExecutorService(ExecutorService executor) { super(executor); } // finalize是当前对象被GC干掉之前要执行的方法 // 当前FinalizableDelegatedExecutorService的目的是为了在当前线程池被GC回收之前 // 可以执行shutdown，shutdown方法是将当前线程池停止，并且干掉工作线程 // 但是不能基于这种方式保证线程池一定会执行shutdown // finalize在执行时，是守护线程，这种线程无法保证一定可以执行完毕。 // 在使用线程池时，如果线程池是基于一个业务构建的，在使用完毕之后，一定要手动执行shutdown， // 否则会造成JVM中一堆线程 protected void finalize() { super.shutdown(); } } 测试单例线程池效果： public static void main(String[] args) throws Exception { ExecutorService threadPool = Executors.newSingleThreadExecutor(); threadPool.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \",\" + \"111\"); }); threadPool.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \",\" + \"222\"); }); threadPool.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \",\" + \"333\"); }); threadPool.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \",\" + \"444\"); }); } 测试线程池使用完毕后，不执行shutdown的后果： 如果是局部变量仅限当前线程池使用的线程池，在使用完毕之后要记得执行shutdown，避免线程无法结束 如果是全局的线程池，很多业务都会到，使用完毕后不要shutdown，因为其他业务也要执行当前线程池 static ExecutorService threadPool = Executors.newFixedThreadPool(200); public static void main(String[] args) throws Exception { newThreadPool(); System.gc(); Thread.sleep(5000); System.out.println(\"线程池被回收了！！\"); System.in.read(); } private static void newThreadPool(){ for (int i = 0; i &lt; 200; i++) { final int a = i; threadPool.execute(() -&gt; { System.out.println(a); }); } threadPool.shutdown(); for (int i = 0; i &lt; 200; i++) { final int a = i; threadPool.execute(() -&gt; { System.out.println(a); }); } } 2.3 newCachedThreadPool看名字好像是一个缓存的线程池，查看一下构建的方式 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); } 当第一次提交任务到线程池时，会直接构建一个工作线程 这个工作线程带执行完人后，60秒没有任务可以执行后，会结束 如果在等待60秒期间有任务进来，他会再次拿到这个任务去执行 如果后续提升任务时，没有线程是空闲的，那么就构建工作线程去执行。 最大的一个特点，任务只要提交到当前的newCachedThreadPool中，就必然有工作线程可以处理 代码测试效果 public static void main(String[] args) throws Exception { ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 1; i &lt;= 200; i++) { final int j = i; executorService.execute(() -&gt; { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":\" + j); }); } } 2.4 newScheduleThreadPool首先看到名字就可以猜到当前线程池是一个定时任务的线程池，而这个线程池就是可以以一定周期去执行一个任务，或者是延迟多久执行一个任务一次 查看一下如何构建的。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } 基于这个方法可以看到，构建的是ScheduledThreadPoolExecutor线程池 public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor{ //.... } 所以本质上还是正常线程池，只不过在原来的线程池基础上实现了定时任务的功能 原理是基于DelayQueue实现的延迟执行。周期性执行是任务执行完毕后，再次扔回到阻塞队列。 代码查看使用的方式和效果 public static void main(String[] args) throws Exception { ScheduledExecutorService pool = Executors.newScheduledThreadPool(10); // 正常执行 // pool.execute(() -&gt; { // System.out.println(Thread.currentThread().getName() + \"：1\"); // }); // 延迟执行，执行当前任务延迟5s后再执行 // pool.schedule(() -&gt; { // System.out.println(Thread.currentThread().getName() + \"：2\"); // },5,TimeUnit.SECONDS); // 周期执行，当前任务第一次延迟5s执行，然后没3s执行一次 // 这个方法在计算下次执行时间时，是从任务刚刚开始时就计算。 // pool.scheduleAtFixedRate(() -&gt; { // try { // Thread.sleep(3000); // } catch (InterruptedException e) { // e.printStackTrace(); // } // System.out.println(System.currentTimeMillis() + \"：3\"); // },2,1,TimeUnit.SECONDS); // 周期执行，当前任务第一次延迟5s执行，然后没3s执行一次 // 这个方法在计算下次执行时间时，会等待任务结束后，再计算时间 pool.scheduleWithFixedDelay(() -&gt; { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(System.currentTimeMillis() + \"：3\"); },2,1,TimeUnit.SECONDS); } 至于Executors提供的newSingleThreadScheduledExecutor单例的定时任务线程池就不说了。 一个线程的线程池可以延迟或者以一定的周期执行一个任务。 2.5 newWorkStealingPool当前JDK提供构建线程池的方式newWorkStealingPool和之前的线程池很非常大的区别 之前定长，单例，缓存，定时任务都基于ThreadPoolExecutor去实现的。 newWorkStealingPool是基于ForkJoinPool构建出来的 ThreadPoolExecutor的核心点： 在ThreadPoolExecutor中只有一个阻塞队列存放当前任务 ForkJoinPool的核心特点： ForkJoinPool从名字上就能看出一些东西。当有一个特别大的任务时，如果采用上述方式，这个大任务只能会某一个线程去执行。ForkJoin第一个特点是可以将一个大任务拆分成多个小任务，放到当前线程的阻塞队列中。其他的空闲线程就可以去处理有任务的线程的阻塞队列中的任务 来一个比较大的数组，里面存满值，计算总和 单线程处理一个任务： /** 非常大的数组 */ static int[] nums = new int[1_000_000_000]; // 填充值 static{ for (int i = 0; i &lt; nums.length; i++) { nums[i] = (int) ((Math.random()) * 1000); } } public static void main(String[] args) { // ===================单线程累加10亿数据================================ System.out.println(\"单线程计算数组总和！\"); long start = System.nanoTime(); int sum = 0; for (int num : nums) { sum += num; } long end = System.nanoTime(); System.out.println(\"单线程运算结果为：\" + sum + \"，计算时间为：\" + (end - start)); } 多线程分而治之的方式处理： /** 非常大的数组 */ static int[] nums = new int[1_000_000_000]; // 填充值 static{ for (int i = 0; i &lt; nums.length; i++) { nums[i] = (int) ((Math.random()) * 1000); } } public static void main(String[] args) { // ===================单线程累加10亿数据================================ System.out.println(\"单线程计算数组总和！\"); long start = System.nanoTime(); int sum = 0; for (int num : nums) { sum += num; } long end = System.nanoTime(); System.out.println(\"单线程运算结果为：\" + sum + \"，计算时间为：\" + (end - start)); // ===================多线程分而治之累加10亿数据================================ // 在使用forkJoinPool时，不推荐使用Runnable和Callable // 可以使用提供的另外两种任务的描述方式 // Runnable(没有返回结果) -&gt; RecursiveAction // Callable(有返回结果) -&gt; RecursiveTask ForkJoinPool forkJoinPool = (ForkJoinPool) Executors.newWorkStealingPool(); System.out.println(\"分而治之计算数组总和！\"); long forkJoinStart = System.nanoTime(); ForkJoinTask&lt;Integer&gt; task = forkJoinPool.submit(new SumRecursiveTask(0, nums.length - 1)); Integer result = task.join(); long forkJoinEnd = System.nanoTime(); System.out.println(\"分而治之运算结果为：\" + result + \"，计算时间为：\" + (forkJoinEnd - forkJoinStart)); } private static class SumRecursiveTask extends RecursiveTask&lt;Integer&gt;{ /** 指定一个线程处理哪个位置的数据 */ private int start,end; private final int MAX_STRIDE = 100_000_000; // 200_000_000： 147964900 // 100_000_000： 145942100 public SumRecursiveTask(int start, int end) { this.start = start; this.end = end; } @Override protected Integer compute() { // 在这个方法中，需要设置好任务拆分的逻辑以及聚合的逻辑 int sum = 0; int stride = end - start; if(stride &lt;= MAX_STRIDE){ // 可以处理任务 for (int i = start; i &lt;= end; i++) { sum += nums[i]; } }else{ // 将任务拆分，分而治之。 int middle = (start + end) / 2; // 声明为2个任务 SumRecursiveTask left = new SumRecursiveTask(start, middle); SumRecursiveTask right = new SumRecursiveTask(middle + 1, end); // 分别执行两个任务 left.fork(); right.fork(); // 等待结果，并且获取sum sum = left.join() + right.join(); } return sum; } } 最终可以发现，这种累加的操作中，采用分而治之的方式效率提升了2倍多。 但是也不是所有任务都能拆分提升效率，首先任务得大，耗时要长。 三、ThreadPoolExecutor应用&amp;源码剖析前面讲到的Executors中的构建线程池的方式，大多数还是基于ThreadPoolExecutor去new出来的。 3.1 为什么要自定义线程池首先ThreadPoolExecutor中，一共提供了7个参数，每个参数都是非常核心的属性，在线程池去执行任务时，每个参数都有决定性的作用。 但是如果直接采用JDK提供的方式去构建，可以设置的核心参数最多就两个，这样就会导致对线程池的控制粒度很粗。所以在阿里规范中也推荐自己去自定义线程池。手动的去new ThreadPoolExecutor设置他的一些核心属性。 自定义构建线程池，可以细粒度的控制线程池，去管理内存的属性，并且针对一些参数的设置可能更好的在后期排查问题。 查看一下ThreadPoolExecutor提供的七个核心参数 public ThreadPoolExecutor( int corePoolSize, // 核心工作线程（当前任务执行结束后，不会被销毁） int maximumPoolSize, // 最大工作线程（代表当前线程池中，一共可以有多少个工作线程） long keepAliveTime, // 非核心工作线程在阻塞队列位置等待的时间 TimeUnit unit, // 非核心工作线程在阻塞队列位置等待时间的单位 BlockingQueue&lt;Runnable&gt; workQueue, // 任务在没有核心工作线程处理时，任务先扔到阻塞队列中 ThreadFactory threadFactory, // 构建线程的线程工作，可以设置thread的一些信息 RejectedExecutionHandler handler) { // 当线程池无法处理投递过来的任务时，执行当前的拒绝策略 // 初始化线程池的操作 } 3.2 ThreadPoolExecutor应用手动new一下，处理的方式还是执行execute或者submit方法。 JDK提供的几种拒绝策略： AbortPolicy：当前拒绝策略会在无法处理任务时，直接抛出一个异常 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException(\"Task \" + r.toString() + \" rejected from \" + e.toString()); } CallerRunsPolicy：当前拒绝策略会在线程池无法处理任务时，将任务交给调用者处理 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); } } DiscardPolicy：当前拒绝策略会在线程池无法处理任务时，直接将任务丢弃掉 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { } DiscardOldestPolicy：当前拒绝策略会在线程池无法处理任务时，将队列中最早的任务丢弃掉，将当前任务再次尝试交给线程池处理 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { e.getQueue().poll(); e.execute(r); } } 自定义Policy：根据自己的业务，可以将任务扔到数据库，也可以做其他操作。 private static class MyRejectedExecution implements RejectedExecutionHandler{ @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { System.out.println(\"根据自己的业务情况，决定编写的代码！\"); } } 代码构建线程池，并处理有无返回结果的任务 public static void main(String[] args) throws ExecutionException, InterruptedException { //1. 构建线程池 ThreadPoolExecutor threadPool = new ThreadPoolExecutor( 2, 5, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5), new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setName(\"test-ThreadPoolExecutor\"); return thread; } }, new MyRejectedExecution() ); //2. 让线程池处理任务,没返回结果 threadPool.execute(() -&gt; { System.out.println(\"没有返回结果的任务\"); }); //3. 让线程池处理有返回结果的任务 Future&lt;Object&gt; future = threadPool.submit(new Callable&lt;Object&gt;() { @Override public Object call() throws Exception { System.out.println(\"我有返回结果！\"); return \"返回结果\"; } }); Object result = future.get(); System.out.println(result); //4. 如果是局部变量的线程池，记得用完要shutdown threadPool.shutdown(); } private static class MyRejectedExecution implements RejectedExecutionHandler{ @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { System.out.println(\"根据自己的业务情况，决定编写的代码！\"); } } 3.3 ThreadPoolExecutor源码剖析线程池的源码内容会比较多一点，需要一点一点的去查看，内部比较多。 3.3.1 ThreadPoolExecutor的核心属性核心属性主要就是ctl，基于ctl拿到线程池的状态以及工作线程个数 在整个线程池的执行流程中，会基于ctl判断上述两个内容 // 当前是线程池的核心属性 // 当前的ctl其实就是一个int类型的数值，内部是基于AtomicInteger套了一层，进行运算时，是原子性的。 // ctl表示着线程池中的2个核心状态： // 线程池的状态：ctl的高3位，表示线程池状态 // 工作线程的数量：ctl的低29位，表示工作线程的个数 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // Integer.SIZE：在获取Integer的bit位个数 // 声明了一个常量：COUNT_BITS = 29 private static final int COUNT_BITS = Integer.SIZE - 3; 00000000 00000000 00000000 00000001 00100000 00000000 00000000 00000000 00011111 11111111 11111111 11111111 // CAPACITY就是当前工作线程能记录的工作线程的最大个数 private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // 线程池状态的表示 // 当前五个状态中，只有RUNNING状态代表线程池没问题，可以正常接收任务处理 // 111：代表RUNNING状态，RUNNING可以处理任务，并且处理阻塞队列中的任务。 private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; // 000：代表SHUTDOWN状态，不会接收新任务，正在处理的任务正常进行，阻塞队列的任务也会做完。 private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; // 001：代表STOP状态，不会接收新任务，正在处理任务的线程会被中断，阻塞队列的任务一个不管。 private static final int STOP = 1 &lt;&lt; COUNT_BITS; // 010：代表TIDYING状态，这个状态是否SHUTDOWN或者STOP转换过来的，代表当前线程池马上关闭，就是过渡状态。 private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; // 011：代表TERMINATED状态，这个状态是TIDYING状态转换过来的，转换过来只需要执行一个terminated方法。 private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 在使用下面这几个方法时，需要传递ctl进来 // 基于&amp;运算的特点，保证只会拿到ctl高三位的值。 private static int runStateOf(int c) { return c &amp; ~CAPACITY; } // 基于&amp;运算的特点，保证只会拿到ctl低29位的值。 private static int workerCountOf(int c) { return c &amp; CAPACITY; } 线程池状态的特点以及转换的方式 3.3.2 ThreadPoolExecutor的有参构造有参构造没啥说的，记住核心线程个数是允许为0的。 // 有参构造。无论调用哪个有参构造，最终都会执行当前的有参构造 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { // 健壮性校验 // 核心线程个数是允许为0个的。 // 最大线程数必须大于0，最大线程数要大于等于核心线程数 // 非核心线程的最大空闲时间，可以等于0 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) // 不满足要求就抛出参数异常 throw new IllegalArgumentException(); // 阻塞队列，线程工厂，拒绝策略都不允许为null，为null就扔空指针异常 if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); // 不要关注当前内容，系统资源访问决策，和线程池核心业务关系不大。 this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); // 各种赋值，JUC包下，几乎所有涉及到线程挂起的操作，单位都用纳秒。 // 有参构造的值，都赋值给成员变量。 // Doug Lea的习惯就是将成员变量作为局部变量单独操作。 this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 3.3.3 ThreadPoolExecutor的execute方法execute方法是提交任务到线程池的核心方法，很重要 线程池的执行流程其实就是在说execute方法内部做了哪些判断 execute源码的分析 // 提交任务到线程池的核心方法 // command就是提交过来的任务 public void execute(Runnable command) { // 提交的任务不能为null if (command == null) throw new NullPointerException(); // 获取核心属性ctl，用于后面的判断 int c = ctl.get(); // 如果工作线程个数，小于核心线程数。 // 满足要求，添加核心工作线程 if (workerCountOf(c) &lt; corePoolSize) { // addWorker(任务,是核心线程吗) // addWorker返回true：代表添加工作线程成功 // addWorker返回false：代表添加工作线程失败 // addWorker中会基于线程池状态，以及工作线程个数做判断，查看能否添加工作线程 if (addWorker(command, true)) // 工作线程构建出来了，任务也交给command去处理了。 return; // 说明线程池状态或者是工作线程个数发生了变化，导致添加失败，重新获取一次ctl c = ctl.get(); } // 添加核心工作线程失败，往这走 // 判断线程池状态是否是RUNNING，如果是，正常基于阻塞队列的offer方法，将任务添加到阻塞队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) { // 如果任务添加到阻塞队列成功，走if内部 // 如果任务在扔到阻塞队列之前，线程池状态突然改变了。 // 重新获取ctl int recheck = ctl.get(); // 如果线程池的状态不是RUNNING，将任务从阻塞队列移除， if (!isRunning(recheck) &amp;&amp; remove(command)) // 并且直接拒绝策略 reject(command); // 在这，说明阻塞队列有我刚刚放进去的任务 // 查看一下工作线程数是不是0个 // 如果工作线程为0个，需要添加一个非核心工作线程去处理阻塞队列中的任务 // 发生这种情况有两种： // 1. 构建线程池时，核心线程数是0个。 // 2. 即便有核心线程，可以设置核心线程也允许超时，设置allowCoreThreadTimeOut为true，代表核心线程也可以超时 else if (workerCountOf(recheck) == 0) // 为了避免阻塞队列中的任务饥饿，添加一个非核心工作线程去处理 addWorker(null, false); } // 任务添加到阻塞队列失败 // 构建一个非核心工作线程 // 如果添加非核心工作线程成功，直接完事，告辞 else if (!addWorker(command, false)) // 添加失败，执行决绝策略 reject(command); } execute方法的完整执行流程图 3.3.4 ThreadPoolExecutor的addWorker方法addWorker中主要分成两大块去看 第一块：校验线程池的状态以及工作线程个数 第二块：添加工作线程并且启动工作线程 校验线程池的状态以及工作线程个数 // 添加工作线程之校验源码 private boolean addWorker(Runnable firstTask, boolean core) { // 外层for循环在校验线程池的状态 // 内层for循环是在校验工作线程的个数 // retry是给外层for循环添加一个标记，是为了方便在内层for循坏跳出外层for循环 retry: for (;;) { // 获取ctl int c = ctl.get(); // 拿到ctl的高3位的值 int rs = runStateOf(c); //==========================线程池状态判断================================================== // 如果线程池状态是SHUTDOWN，并且此时阻塞队列有任务，工作线程个数为0，添加一个工作线程去处理阻塞队列的任务 // 判断线程池的状态是否大于等于SHUTDOWN，如果满足，说明线程池不是RUNNING if (rs &gt;= SHUTDOWN &amp;&amp; // 如果这三个条件都满足，就代表是要添加非核心工作线程去处理阻塞队列任务 // 如果三个条件有一个没满足，返回false，配合!，就代表不需要添加 !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) // 不需要添加工作线程 return false; for (;;) { //==========================工作线程个数判断================================================== // 基于ctl拿到低29位的值，代表当前工作线程个数 int wc = workerCountOf(c); // 如果工作线程个数大于最大值了，不可以添加了，返回false if (wc &gt;= CAPACITY || // 基于core来判断添加的是否是核心工作线程 // 如果是核心：基于corePoolSize去判断 // 如果是非核心：基于maximumPoolSize去判断 wc &gt;= (core ? corePoolSize : maximumPoolSize)) // 代表不能添加，工作线程个数不满足要求 return false; // 针对ctl进行 + 1，采用CAS的方式 if (compareAndIncrementWorkerCount(c)) // CAS成功后，直接退出外层循环，代表可以执行添加工作线程操作了。 break retry; // 重新获取一次ctl的值 c = ctl.get(); // 判断重新获取到的ctl中，表示的线程池状态跟之前的是否有区别 // 如果状态不一样，说明有变化，重新的去判断线程池状态 if (runStateOf(c) != rs) // 跳出一次外层for循环 continue retry; } } // 省略添加工作线程以及启动的过程 } 添加工作线程并且启动工作线程 private boolean addWorker(Runnable firstTask, boolean core) { // 省略校验部分的代码 // 添加工作线程以及启动工作线程~~~ // 声明了三个变量 // 工作线程启动了没，默认false boolean workerStarted = false; // 工作线程添加了没，默认false boolean workerAdded = false; // 工作线程，默认为null Worker w = null; try { // 构建工作线程，并且将任务传递进去 w = new Worker(firstTask); // 获取了Worker中的Thread对象 final Thread t = w.thread; // 判断Thread是否不为null，在new Worker时，内部会通过给予的ThreadFactory去构建Thread交给Worker // 一般如果为null，代表ThreadFactory有问题。 if (t != null) { // 加锁，保证使用workers成员变量以及对largestPoolSize赋值时，保证线程安全 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 再次获取线程池状态。 int rs = runStateOf(ctl.get()); // 再次判断 // 如果满足 rs &lt; SHUTDOWN 说明线程池是RUNNING，状态正常，执行if代码块 // 如果线程池状态为SHUTDOWN，并且firstTask为null，添加非核心工作处理阻塞队列任务 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) { // 到这，可以添加工作线程。 // 校验ThreadFactory构建线程后，不能自己启动线程，如果启动了，抛出异常 if (t.isAlive()) throw new IllegalThreadStateException(); // private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // 将new好的Worker添加到HashSet中。 workers.add(w); // 获取了HashSet的size，拿到工作线程个数 int s = workers.size(); // largestPoolSize在记录最大线程个数的记录 // 如果当前工作线程个数，大于最大线程个数的记录，就赋值 if (s &gt; largestPoolSize) largestPoolSize = s; // 添加工作线程成功 workerAdded = true; } } finally { mainLock.unlock(); } // 如果工作线程添加成功， if (workerAdded) { // 直接启动Worker中的线程 t.start(); // 启动工作线程成功 workerStarted = true; } } } finally { // 做补偿的操作，如果工作线程启动失败，将这个添加失败的工作线程处理掉 if (!workerStarted) addWorkerFailed(w); } // 返回工作线程是否启动成功 return workerStarted; } // 工作线程启动失败，需要不的步长操作 private void addWorkerFailed(Worker w) { // 因为操作了workers，需要加锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 如果w不为null，之前Worker已经new出来了。 if (w != null) // 从HashSet中移除 workers.remove(w); // 同时对ctl进行 - 1，代表去掉了一个工作线程个数 decrementWorkerCount(); // 因为工作线程启动失败，判断一下状态的问题，是不是可以走TIDYING状态最终到TERMINATED状态了。 tryTerminate(); } finally { // 释放锁 mainLock.unlock(); } } 3.3.5 ThreadPoolExecutor的Worker工作线程Worker对象主要包含了两个内容 工作线程要执行任务 工作线程可能会被中断，控制中断 // Worker继承了AQS，目的就是为了控制工作线程的中断。 // Worker实现了Runnable，内部的Thread对象，在执行start时，必然要执行Worker中断额一些操作 private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ // =======================Worker管理任务================================ // 线程工厂构建的线程 final Thread thread; // 当前Worker要执行的任务 Runnable firstTask; // 记录当前工作线程处理了多少个任务。 volatile long completedTasks; // 有参构造 Worker(Runnable firstTask) { // 将State设置为-1，代表当前不允许中断线程 setState(-1); // 任务赋值 this.firstTask = firstTask; // 基于线程工作构建Thread，并且传入的Runnable是Worker this.thread = getThreadFactory().newThread(this); } // 当thread执行start方法时，调用的是Worker的run方法， public void run() { // 任务执行时，执行的是runWorker方法 runWorker(this); } // =======================Worker管理中断================================ // 当前方法是中断工作线程时，执行的方法 void interruptIfStarted() { Thread t; // 只有Worker中的state &gt;= 0的时候，可以中断工作线程 if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) { try { // 如果状态正常，并且线程未中断，这边就中断线程 t.interrupt(); } catch (SecurityException ignore) { } } } protected boolean isHeldExclusively() { return getState() != 0; } protected boolean tryAcquire(int unused) { if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } protected boolean tryRelease(int unused) { setExclusiveOwnerThread(null); setState(0); return true; } public void lock() { acquire(1); } public boolean tryLock() { return tryAcquire(1); } public void unlock() { release(1); } public boolean isLocked() { return isHeldExclusively(); } } 3.3.6 ThreadPoolExecutor的runWorker方法runWorker就是让工作线程拿到任务去执行即可。 并且在内部也处理了在工作线程正常结束和异常结束时的处理方案 // 工作线程启动后执行的任务。 final void runWorker(Worker w) { // 拿到当前线程 Thread wt = Thread.currentThread(); // 从worker对象中拿到任务 Runnable task = w.firstTask; // 将Worker中的firstTask置位空 w.firstTask = null; // 将Worker中的state置位0，代表当前线程可以中断的 w.unlock(); // allow interrupts // 判断工作线程是否是异常结束，默认就是异常结束 boolean completedAbruptly = true; try { // 获取任务 // 直接拿到第一个任务去执行 // 如果第一个任务为null，去阻塞队列中获取任务 while (task != null || (task = getTask()) != null) { // 执行了Worker的lock方法，当前在lock时，shutdown操作不能中断当前线程，因为当前线程正在处理任务 w.lock(); // 比较ctl &gt;= STOP,如果满足找个状态，说明线程池已经到了STOP状态甚至已经要凉凉了 // 线程池到STOP状态，并且当前线程还没有中断，确保线程是中断的，进到if内部执行中断方法 // if(runStateAtLeast(ctl.get(), STOP) &amp;&amp; !wt.isInterrupted()) {中断线程} // 如果线程池状态不是STOP，确保线程不是中断的。 // 如果发现线程中断标记位是true了，再次查看线程池状态是大于STOP了，再次中断线程 // 这里其实就是做了一个事情，如果线程池状态 &gt;= STOP，确保线程中断了。 if ( ( runStateAtLeast(ctl.get(), STOP) || ( Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP) ) ) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try { // 勾子函数在线程池中没有做任何的实现，如果需要在线程池执行任务前后做一些额外的处理，可以重写勾子函数 // 前置勾子函数 beforeExecute(wt, task); Throwable thrown = null; try { // 执行任务。 task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { // 前后置勾子函数 afterExecute(task, thrown); } } finally { // 任务执行完，丢掉任务 task = null; // 当前工作线程处理的任务数+1 w.completedTasks++; // 执行unlock方法，此时shutdown方法才可以中断当前线程 w.unlock(); } } // 如果while循环结束，正常走到这，说明是正常结束 // 正常结束的话，在getTask中就会做一个额外的处理，将ctl - 1，代表工作线程没一个。 completedAbruptly = false; } finally { // 考虑干掉工作线程 processWorkerExit(w, completedAbruptly); } } // 工作线程结束前，要执行当前方法 private void processWorkerExit(Worker w, boolean completedAbruptly) { // 如果是异常结束 if (completedAbruptly) // 将ctl - 1，扣掉一个工作线程 decrementWorkerCount(); // 操作Worker，为了线程安全，加锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 当前工作线程处理的任务个数累加到线程池处理任务的个数属性中 completedTaskCount += w.completedTasks; // 将工作线程从hashSet中移除 workers.remove(w); } finally { // 释放锁 mainLock.unlock(); } // 只要工作线程凉了，查看是不是线程池状态改变了。 tryTerminate(); // 获取ctl int c = ctl.get(); // 判断线程池状态，当前线程池要么是RUNNING，要么是SHUTDOWN if (runStateLessThan(c, STOP)) { // 如果正常结束工作线程 if (!completedAbruptly) { // 如果核心线程允许超时，min = 0，否则就是核心线程个数 int min = allowCoreThreadTimeOut ? 0 : corePoolSize; // 如果min == 0，可能会出现没有工作线程，并且阻塞队列有任务没有线程处理 if (min == 0 &amp;&amp; ! workQueue.isEmpty()) // 至少要有一个工作线程处理阻塞队列任务 min = 1; // 如果工作线程个数 大于等于1，不怕没线程处理，正常return if (workerCountOf(c) &gt;= min) return; } // 异常结束，为了避免出现问题，添加一个空任务的非核心线程来填补上刚刚异常结束的工作线程 addWorker(null, false); } } 3.3.7 ThreadPoolExecutor的getTask方法工作线程在去阻塞队列获取任务前，要先查看线程池状态 如果状态没问题，去阻塞队列take或者是poll任务 第二个循环时，不但要判断线程池状态，还要判断当前工作线程是否可以被干掉 // 当前方法就在阻塞队列中获取任务 // 前面半部分是判断当前工作线程是否可以返回null，结束。 // 后半部分就是从阻塞队列中拿任务 private Runnable getTask() { // timeOut默认值是false。 boolean timedOut = false; // 死循环 for (;;) { // 拿到ctl int c = ctl.get(); // 拿到线程池的状态 int rs = runStateOf(c); // 如果线程池状态是STOP，没有必要处理阻塞队列任务，直接返回null // 如果线程池状态是SHUTDOWN，并且阻塞队列是空的，直接返回null if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) { // 如果可以返回null，先扣减工作线程个数 decrementWorkerCount(); // 返回null，结束runWorker的while循环 return null; } // 基于ctl拿到工作线程个数 int wc = workerCountOf(c); // 核心线程允许超时，timed为true // 工作线程个数大于核心线程数，timed为true boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ( // 如果工作线程个数，大于最大线程数。（一般情况不会满足），把他看成false // 第二个判断代表，只要工作线程数小于等于核心线程数，必然为false // 即便工作线程个数大于核心线程数了，此时第一次循环也不会为true，因为timedOut默认值是false // 考虑第二次循环了，因为循环内部必然有修改timeOut的位置 (wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; // 要么工作线程还有，要么阻塞队列为空，并且满足上述条件后，工作线程才会走到if内部，结束工作线程 (wc &gt; 1 || workQueue.isEmpty()) ) { // 第二次循环才有可能到这。 // 正常结束，工作线程 - 1，因为是CAS操作，如果失败了，重新走for循环 if (compareAndDecrementWorkerCount(c)) return null; continue; } // 工作线程从阻塞队列拿任务 try { // 如果是核心线程，timed是false，如果是非核心线程，timed就是true Runnable r = timed ? // 如果是非核心，走poll方法，拿任务，等待一会 workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : // 如果是核心，走take方法，死等。 workQueue.take(); // 从阻塞队列拿到的任务不为null，这边就正常返回任务，去执行 if (r != null) return r; // 说明当前线程没拿到任务，将timeOut设置为true，在上面就可以返回null退出了。 timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } 3.3.8 ThreadPoolExecutor的关闭方法首先查看shutdownNow方法，可以从RUNNING状态转变为STOP // shutDownNow方法，shutdownNow不会处理阻塞队列的任务，将任务全部给你返回了。 public List&lt;Runnable&gt; shutdownNow() { // 声明返回结果 List&lt;Runnable&gt; tasks; // 加锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 不关注这个方法…… checkShutdownAccess(); // 将线程池状态修改为STOP advanceRunState(STOP); // 无论怎么，直接中断工作线程。 interruptWorkers(); // 将阻塞队列的任务全部扔到List集合中。 tasks = drainQueue(); } finally { // 释放锁 mainLock.unlock(); } tryTerminate(); return tasks; } // 将线程池状态修改为STOP private void advanceRunState(int STOP) { // 死循环。 for (;;) { // 获取ctl属性的值 int c = ctl.get(); // 第一个判断：如果当前线程池状态已经大于等于STOP了，不管了，告辞。 if (runStateAtLeast(c, STOP) || // 基于CAS，将ctl从c修改为STOP状态，不修改工作线程个数，但是状态变为了STOP // 如果修改成功结束 ctl.compareAndSet(c, ctlOf(STOP, workerCountOf(c)))) break; } } // 无论怎么，直接中断工作线程。 private void interruptWorkers() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 遍历HashSet，拿到所有的工作线程，直接中断。 for (Worker w : workers) w.interruptIfStarted(); } finally { mainLock.unlock(); } } // 移除阻塞队列，内容全部扔到List集合中 private List&lt;Runnable&gt; drainQueue() { BlockingQueue&lt;Runnable&gt; q = workQueue; ArrayList&lt;Runnable&gt; taskList = new ArrayList&lt;Runnable&gt;(); // 阻塞队列自带的，直接清空阻塞队列，内容扔到List集合 q.drainTo(taskList); // 为了避免任务丢失，重新判断，是否需要编辑阻塞队列，重新扔到List if (!q.isEmpty()) { for (Runnable r : q.toArray(new Runnable[0])) { if (q.remove(r)) taskList.add(r); } } return taskList; } // 查看当前线程池是否可以变为TERMINATED状态 final void tryTerminate() { // 死循环。 for (;;) { // 拿到ctl int c = ctl.get(); // 如果是RUNNING，直接告辞。 // 如果状态已经大于等于TIDYING，马上就要凉凉，直接告辞。 // 如果状态是SHUTDOWN，但是阻塞队列还有任务，直接告辞。 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return; // 如果还有工作线程 if (workerCountOf(c) != 0) { // 再次中断工作线程 interruptIdleWorkers(ONLY_ONE); // 告辞，等你工作线程全完事，我这再尝试进入到TERMINATED状态 return; } // 加锁，为了可以执行Condition的释放操作 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 将线程池状态修改为TIDYING状态，如果成功，继续往下走 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) { try { // 这个方法是空的，如果你需要在线程池关闭后做一些额外操作，这里你可以自行实现 terminated(); } finally { // 最终修改为TERMINATED状态 ctl.set(ctlOf(TERMINATED, 0)); // 线程池提供了一个方法，主线程在提交任务到线程池后，是可以继续做其他操作的。 // 咱们也可以让主线程提交任务后，等待线程池处理完毕，再做后续操作 // 这里线程池凉凉后，要唤醒哪些调用了awaitTermination方法的线程 termination.signalAll(); } return; } } finally { mainLock.unlock(); } // else retry on failed CAS } } 再次shutdown方法，可以从RUNNING状态转变为SHUTDOWN shutdown状态下，不会中断正在干活的线程，而且会处理阻塞队列中的任务 public void shutdown() { // 加锁。。 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 不看。 checkShutdownAccess(); // 里面是一个死循环，将线程池状态修改为SHUTDOWN advanceRunState(SHUTDOWN); // 中断空闲线程 interruptIdleWorkers(); // 说了，这个是为了ScheduleThreadPoolExecutor准备的，不管 onShutdown(); } finally { mainLock.unlock(); } // 尝试结束线程 tryTerminate(); } // 中断空闲线程 private void interruptIdleWorkers(boolean onlyOne) { // 加锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { for (Worker w : workers) { Thread t = w.thread; // 如果线程没有中断，那么就去获取Worker的锁，基于tryLock可知，不会中断正在干活的线程 if (!t.isInterrupted() &amp;&amp; w.tryLock()) { try { // 会中断空闲线程 t.interrupt(); } catch (SecurityException ignore) { } finally { w.unlock(); } } if (onlyOne) break; } } finally { mainLock.unlock(); } } 3.4 线程池的核心参数设计规则线程池的使用难度不大，难度在于线程池的参数并不好配置。 主要难点在于任务类型无法控制，比如任务有CPU密集型，还有IO密集型，甚至还有混合型的。 因为IO咱们无法直接控制，所以很多时间按照一些书上提供的一些方法，是无法解决问题的。 《Java并发编程实践》 想调试出一个符合当前任务情况的核心参数，最好的方式就是测试。 需要将项目部署到测试环境或者是沙箱环境中，结果各种压测得到一个相对符合的参数。 如果每次修改项目都需要重新部署，成本太高了。 此时咱们可以实现一个动态监控以及修改线程池的方案。 因为线程池的核心参数无非就是： corePoolSize：核心线程数 maximumPoolSize：最大线程数 workQueue：工作队列 线程池中提供了获取核心信息的get方法，同时也提供了动态修改核心属性的set方法。 也可以采用一些开源项目提供的方式去做监控和修改 比如hippo4j就可以对线程池进行监控，而且可以和SpringBoot整合。 Github地址：https://github.com/opengoofy/hippo4j 官方文档：https://hippo4j.cn/docs/user_docs/intro 3.5 线程池处理任务的核心流程基于addWorker添加工作线程的流程切入到整体处理任务的位置 四、ScheduleThreadPoolExecutor应用&amp;源码4.1 ScheduleThreadPoolExecutor介绍从名字上就可以看出，当前线程池是用于执行定时任务的线程池。 Java比较早的定时任务工具是Timer类。但是Timer问题很多，串行的，不靠谱，会影响到其他的任务执行。 其实除了Timer以及ScheduleThreadPoolExecutor之外，正常在企业中一般会采用Quartz或者是SpringBoot提供的Schedule的方式去实现定时任务的功能。 ScheduleThreadPoolExecutor支持延迟执行以及周期性执行的功能。 4.2 ScheduleThreadPoolExecutor应用定时任务线程池的有参构造 public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory, handler); } 发现ScheduleThreadPoolExecutor在构建时，直接调用了父类的构造方法 ScheduleThreadPoolExecutor的父类就是ThreadPoolExecutor 首先ScheduleThreadPoolExecutor最多允许设置3个参数： 核心线程数 线程工厂 拒绝策略 首先没有设置阻塞队列，以及最大线程数和空闲时间以及单位 阻塞队列设置的是DelayedWorkQueue，其实本质就是DelayQueue，一个延迟队列。DelayQueue是一个无界队列。所以最大线程数以及非核心线程的空闲时间是不需要设置的。 代码落地使用 public static void main(String[] args) { //1. 构建定时任务线程池 ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor( 5, new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread t = new Thread(r); return t; } }, new ThreadPoolExecutor.AbortPolicy() ); //2. 应用ScheduledThreadPoolExecutor // 跟直接执行线程池的execute没啥区别 pool.execute(() -&gt; { System.out.println(\"execute\"); }); // 指定延迟时间执行 System.out.println(System.currentTimeMillis()); pool.schedule(() -&gt; { System.out.println(\"schedule\"); System.out.println(System.currentTimeMillis()); },2, TimeUnit.SECONDS); // 指定第一次的延迟时间，并且确认后期的周期执行时间，周期时间是在任务开始时就计算 // 周期性执行就是将执行完毕的任务再次社会好延迟时间，并且重新扔到阻塞队列 // 计算的周期执行，也是在原有的时间上做累加，不关注任务的执行时长。 System.out.println(System.currentTimeMillis()); pool.scheduleAtFixedRate(() -&gt; { System.out.println(\"scheduleAtFixedRate\"); System.out.println(System.currentTimeMillis()); },2,3,TimeUnit.SECONDS); // // 指定第一次的延迟时间，并且确认后期的周期执行时间，周期时间是在任务结束后再计算下次的延迟时间 System.out.println(System.currentTimeMillis()); pool.scheduleWithFixedDelay(() -&gt; { System.out.println(\"scheduleWithFixedDelay\"); System.out.println(System.currentTimeMillis()); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } },2,3,TimeUnit.SECONDS); } 4.3 ScheduleThreadPoolExecutor源码剖析4.3.1 核心属性后面的方法业务流程会涉及到这些属性。 // 这里是针对任务取消时的一些业务判断会用到的标记 private volatile boolean continueExistingPeriodicTasksAfterShutdown; private volatile boolean executeExistingDelayedTasksAfterShutdown = true; private volatile boolean removeOnCancel = false; // 计数器，如果两个任务的执行时间节点一模一样，根据这个序列来判断谁先执行 private static final AtomicLong sequencer = new AtomicLong(); // 这个方法是获取当前系统时间的毫秒值 final long now() { return System.nanoTime(); } // 内部类。核心类之一。 private class ScheduledFutureTask&lt;V&gt; extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; { // 全局唯一的序列，如果两个任务时间一直，基于当前属性判断 private final long sequenceNumber; // 任务执行的时间，单位纳秒 private long time; /** * period == 0：执行一次的延迟任务 * period &gt; 0：代表是At * period &lt; 0：代表是With */ private final long period; // 周期性执行时，需要将任务重新扔回阻塞队列，基础当前属性拿到任务，方便扔回阻塞队列 RunnableScheduledFuture&lt;V&gt; outerTask = this; /** * 构建schedule方法的任务 */ ScheduledFutureTask(Runnable r, V result, long ns) { super(r, result); this.time = ns; this.period = 0; this.sequenceNumber = sequencer.getAndIncrement(); } /** * 构建At和With任务的有参构造 */ ScheduledFutureTask(Runnable r, V result, long ns, long period) { super(r, result); this.time = ns; this.period = period; this.sequenceNumber = sequencer.getAndIncrement(); } } // 内部类。核心类之一。 static class DelayedWorkQueue extends AbstractQueue&lt;Runnable&gt; implements BlockingQueue&lt;Runnable&gt; { // 这个类就是DelayQueue，不用过分关注，如果没看过，看阻塞队列中的优先级队列和延迟队列 4.3.2 schedule方法execute方法也是调用的schedule方法，只不过传入的延迟时间是0纳秒 schedule方法就是将任务和延迟时间封装到一起，并且将任务扔到阻塞队列中，再去创建工作线程去take阻塞队列。 // 延迟任务执行的方法。 // command：任务 // delay：延迟时间 // unit：延迟时间的单位 public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) { // 健壮性校验。 if (command == null || unit == null) throw new NullPointerException(); // 将任务和延迟时间封装到一起，最终组成ScheduledFutureTask // 要分成三个方法去看 // triggerTime：计算延迟时间。最终返回的是当前系统时间 + 延迟时间 // triggerTime就是将延迟时间转换为纳秒，并且+当前系统时间，再做一些健壮性校验 // ScheduledFutureTask有参构造：将任务以及延迟时间封装到一起，并且设置任务执行的方式 // decorateTask：当前方式是让用户基于自身情况可以动态修改任务的一个扩展口 RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); // 任务封装好，执行delayedExecute方法，去执行任务 delayedExecute(t); // 返回FutureTask return t; } // triggerTime做的事情 // 外部方法，对延迟时间做校验，如果小于0，就直接设置为0 // 并且转换为纳秒单位 private long triggerTime(long delay, TimeUnit unit) { return triggerTime(unit.toNanos((delay &lt; 0) ? 0 : delay)); } // 将延迟时间+当前系统时间 // 后面的校验是为了避免延迟时间超过Long的取值范围 long triggerTime(long delay) { return now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; 1)) ? delay : overflowFree(delay)); } // ScheduledFutureTask有参构造 ScheduledFutureTask(Runnable r, V result, long ns) { super(r, result); // time就是任务要执行的时间 this.time = ns; // period,为0，代表任务是延迟执行，不是周期执行 this.period = 0; // 基于AtmoicLong生成的序列 this.sequenceNumber = sequencer.getAndIncrement(); } // delayedExecute 执行延迟任务的操作 private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) { // 查看当前线程池是否还是RUNNING状态，如果不是RUNNING，进到if if (isShutdown()) // 不是RUNNING。 // 执行拒绝策略。 reject(task); else { // 线程池状态是RUNNING // 直接让任务扔到延迟的阻塞队列中 super.getQueue().add(task); // DCL的操作，再次查看线程池状态 // 如果线程池在添加任务到阻塞队列后，状态不是RUNNING if (isShutdown() &amp;&amp; // task.isPeriodic()：现在反回的是false，因为任务是延迟执行，不是周期执行 // 默认情况，延迟队列中的延迟任务，可以执行 !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; // 从阻塞队列中移除任务。 remove(task)) task.cancel(false); else // 线程池状态正常，任务可以执行 ensurePrestart(); } } // 线程池状态不为RUNNING，查看任务是否可以执行 // 延迟执行：periodic==false // 周期执行：periodic==true // continueExistingPeriodicTasksAfterShutdown：周期执行任务，默认为false // executeExistingDelayedTasksAfterShutdown：延迟执行任务，默认为true boolean canRunInCurrentRunState(boolean periodic) { return isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown : executeExistingDelayedTasksAfterShutdown); } // 当前情况，shutdownOK为true final boolean isRunningOrShutdown(boolean shutdownOK) { int rs = runStateOf(ctl.get()); // 如果状态是RUNNING，正常可以执行，返回true // 如果状态是SHUTDOWN，根据shutdownOK来决定 return rs == RUNNING || (rs == SHUTDOWN &amp;&amp; shutdownOK); } // 任务可以正常执行后，做的操作 void ensurePrestart() { // 拿到工作线程个数 int wc = workerCountOf(ctl.get()); // 如果工作线程个数小于核心线程数 if (wc &lt; corePoolSize) // 添加核心线程去处理阻塞队列中的任务 addWorker(null, true); else if (wc == 0) // 如果工作线程数为0，核心线程数也为0，这是添加一个非核心线程去处理阻塞队列任务 addWorker(null, false); } 4.3.3 At和With方法&amp;任务的run方法这两个方法在源码层面上的第一个区别，就是在计算周期时间时，需要将这个值传递给period，基于正负数在区别At和With 所以查看一个方法就ok，查看At方法 // At方法， // command：任务 // initialDelay：第一次执行的延迟时间 // period：任务的周期执行时间 // unit：上面两个时间的单位 public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) { // 健壮性校验 if (command == null || unit == null) throw new NullPointerException(); // 周期时间不能小于等于0. if (period &lt;= 0) throw new IllegalArgumentException(); // 将任务以及第一次的延迟时间，和后续的周期时间封装好。 ScheduledFutureTask&lt;Void&gt; sft = new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(initialDelay, unit), unit.toNanos(period)); // 扩展口，可以对任务做修改。 RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft); // 周期性任务，需要在任务执行完毕后，重新扔会到阻塞队列，为了方便拿任务，将任务设置到outerTask成员变量中 sft.outerTask = t; // 和schedule方法一样的方式 // 如果任务刚刚扔到阻塞队列，线程池状态变为SHUTDOWN，默认情况，当前任务不执行 delayedExecute(t); return t; } // 延迟任务以及周期任务在执行时，都会调用当前任务的run方法。 public void run() { // periodic == false：一次性延迟任务 // periodic == true：周期任务 boolean periodic = isPeriodic(); // 任务执行前，会再次判断状态，能否执行任务 if (!canRunInCurrentRunState(periodic)) cancel(false); // 判断是周期执行还是一次性任务 else if (!periodic) // 一次性任务，让工作线程直接执行command的逻辑 ScheduledFutureTask.super.run(); // 到这个else if，说明任务是周期执行 else if (ScheduledFutureTask.super.runAndReset()) { // 设置下次任务执行的时间 setNextRunTime(); // 将任务重新扔回线程池做处理 reExecutePeriodic(outerTask); } } // 设置下次任务执行的时间 private void setNextRunTime() { // 拿到period值，正数：At，负数：With long p = period; if (p &gt; 0) // 拿着之前的执行时间，直接追加上周期时间 time += p; else // 如果走到else，代表任务是With方式，这种方式要重新计算延迟时间 // 拿到当前系统时间，追加上延迟时间， time = triggerTime(-p); } // 将任务重新扔回线程池做处理 void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) { // 如果状态ok，可以执行 if (canRunInCurrentRunState(true)) { // 将任务扔到延迟队列 super.getQueue().add(task); // DCL，判断线程池状态 if (!canRunInCurrentRunState(true) &amp;&amp; remove(task)) task.cancel(false); else // 添加工作线程 ensurePrestart(); } }","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tangtangchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://tangtangchen.github.io/tags/%E6%83%B3%E6%B3%95/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://tangtangchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}]},{"title":"博客诞生","slug":"01-博客诞生","date":"2022-10-24T13:00:00.000Z","updated":"2023-08-22T06:12:15.304Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://tangtangchen.github.io/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有一个自己的博客写一些自己感兴趣的事或物,不是一件很酷的事嘛! 展望博客我会整理一些个人所学的知识或生活方面有兴趣的事发到博客上供大家观摩 关于博主有位可爱的（小）朋友，给我取名叫 “仙气”，这是也是我博客上自居 “仙气” 的由来。喜欢自己所喜欢的，做自己想做的，追求自由与潇洒，多酷啊！ 想法是美好的，可现实… … 给大家推荐一首诗吧 《自由与爱情》---作者:裴多菲 ​ 生命诚可贵 ​ 爱情价更高 ​ 若为自由故 ​ 二者皆可抛 溜溜球啦！","categories":[{"name":"生活","slug":"生活","permalink":"https://tangtangchen.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://tangtangchen.github.io/tags/%E6%83%B3%E6%B3%95/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://tangtangchen.github.io/categories/%E7%94%9F%E6%B4%BB/"}]}]}