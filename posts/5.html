<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>并发编程 | C</title><meta name="keywords" content="想法"><meta name="author" content="小陈"><meta name="copyright" content="小陈"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java并发并发编程的三个基本概念原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行； 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值； 有序性：即程序执行的顺序按照代码的先后顺序执行。 线程线程跟进程线程是进程划分成的更小的运行单位； 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程">
<meta property="og:url" content="https://tangtangchen.github.io/posts/5.html">
<meta property="og:site_name" content="C">
<meta property="og:description" content="Java并发并发编程的三个基本概念原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行； 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值； 有序性：即程序执行的顺序按照代码的先后顺序执行。 线程线程跟进程线程是进程划分成的更小的运行单位； 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp">
<meta property="article:published_time" content="2022-12-24T13:00:00.000Z">
<meta property="article:modified_time" content="2023-08-22T06:01:15.493Z">
<meta property="article:author" content="小陈">
<meta property="article:tag" content="想法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp"><link rel="shortcut icon" href="https://s1.ax1x.com/2022/10/24/xR9pLj.jpg"><link rel="canonical" href="https://tangtangchen.github.io/posts/5"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"一年之内的产物","messageNext":"技术可能存在过期"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 小陈","link":"链接: ","source":"来源: C","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-22 14:01:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link defer rel="stylesheet" href="/css/customm.css" ><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/icon.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/background.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/index_ee.css"><meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="C" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/24/xR9pLj.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/Windows/"><i class="fa-fw fa fa-desktop"></i><span> Windows</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">C</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/Windows/"><i class="fa-fw fa fa-desktop"></i><span> Windows</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-24T13:00:00.000Z" title="发表于 2022-12-24 21:00:00">2022-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-22T06:01:15.493Z" title="更新于 2023-08-22 14:01:15">2023-08-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="并发编程的三个基本概念"><a href="#并发编程的三个基本概念" class="headerlink" title="并发编程的三个基本概念"></a>并发编程的三个基本概念</h2><p>原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行；</p>
<p>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值；</p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程跟进程"><a href="#线程跟进程" class="headerlink" title="线程跟进程"></a>线程跟进程</h3><p>线程是进程划分成的更小的运行单位；</p>
<p>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位；</p>
<p>一个进程中可以有多个线程，多个线程共享进程中的堆和方法区；线程私有自己的程序计数器、虚拟机栈和本地方法栈；</p>
<p>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><h4 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的"></a>程序计数器为什么是私有的</h4><p>线程切换后能恢复到正确的执行位置</p>
<h4 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的"></a>虚拟机栈和本地方法栈为什么是私有的</h4><p>为了保证线程的局部变量不被其他线程访问到</p>
<h3 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h3><p>充分利用多核CPU的性能，提升系统的性能</p>
<h3 id="线程的生命周期和六种状态"><a href="#线程的生命周期和六种状态" class="headerlink" title="线程的生命周期和六种状态"></a>线程的生命周期和六种状态</h3><p>线程的生命周期中并不是固定处于某个状态，而是随着代码的执行在不同状态之间切换。</p>
<p>new：初始状态，线程被创建出来但是没有被调用start（）；</p>
<p>runnable：运行状态，线程被调用start（）等待被运行；</p>
<p>blocked：阻塞状态，等待锁释放；</p>
<p>waiting：等待状态，线程需要其他线程做出一些特定动作（通知或中断）</p>
<p>time_waiting：超时等待状态，可以在指定时间后自行返回，而非waiting那样一直等待；</p>
<p>terminated：终止状态，表示该线程已经运行完毕；</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230821214408533.png" alt="image-20230821214408533"></p>
<p>新建状态（NEW）：</p>
<p>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值</p>
<p>就绪状态（RUNNABLE）：</p>
<p>当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>
<p>运行状态（RUNNING）：</p>
<p>如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。</p>
<p>阻塞状态（BLOCKED）：</p>
<p>阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。 直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状 态。阻塞的情况分三种：</p>
<p>等待阻塞（o.wait-&gt;等待对列）：</p>
<p>运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue) 中。 </p>
<p>同步阻塞（lock-&gt;锁池）：</p>
<p>运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线 程放入锁池(lock pool)中。</p>
<p>其他阻塞(sleep/join）：</p>
<p>运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时， JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态。</p>
<p>线程死亡（DEAD）：</p>
<p>线程会以下面三种方式结束，结束后就是死亡状态。 </p>
<p>正常结束 </p>
<p>run()或 call()方法执行完成，线程正常结束。 </p>
<p>异常结束 </p>
<p>线程抛出一个未捕获的 Exception 或 Error。 </p>
<p>调用 stop 3. </p>
<p>直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用</p>
<h3 id="终止线程4种方式"><a href="#终止线程4种方式" class="headerlink" title="终止线程4种方式"></a>终止线程4种方式</h3><ul>
<li>正常运行结束</li>
</ul>
<p>程序运行结束，线程自动结束。</p>
<ul>
<li>使用退出标志退出线程</li>
</ul>
<p>一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的 运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环</p>
<ul>
<li>Interrupt 方法结束线程</li>
</ul>
<p>使用 interrupt()方法来中断线程有两种情况：</p>
<p>1、线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时， 会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的，一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。 </p>
<p>2、线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用 interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p>
<ul>
<li>stop 方法终止线程（线程不安全）</li>
</ul>
<p>程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关 闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是： thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子 线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用 thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈 现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因 此，并不推荐使用 stop 方法来终止线程。</p>
<h3 id="sleep-与-wait-区别"><a href="#sleep-与-wait-区别" class="headerlink" title="sleep 与 wait 区别"></a>sleep 与 wait 区别</h3><ol>
<li>对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于 Object 类中的。 </li>
<li>  sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 </li>
<li>在调用 sleep()方法的过程中，线程不会释放对象锁。</li>
<li>而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li>
</ol>
<h3 id="线程基本方法"><a href="#线程基本方法" class="headerlink" title="线程基本方法"></a>线程基本方法</h3><p>wait、sleep、notify、notifyAll、join、yield等</p>
<p><strong>wait</strong>：线程等待</p>
<p>调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait（）方法后，会释放对象的锁。因此，wait方法一般用在同步方法或同步代码块中。</p>
<p><strong>sleep</strong>：线程睡眠</p>
<p>sleep导致当前线程休眠，与wait方法不同的是sleep不会释放当前占有的锁，sleep（long）会导致线程进入TIMEED-WAITING状态</p>
<p><strong>yield</strong>：线程让步</p>
<p>yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片。</p>
<p><strong>interrupt</strong>：线程中断</p>
<p>中断一个线程，本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态（如阻塞，终止等）</p>
<ol>
<li>调用interrupt（）方法并不会中断一个正在运行的线程。也就是说处于Running状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标记位而已。</li>
<li>若调用sleep（）而使线程处于TIMED-WAITING状态，这是调用interrupt（）方法，会抛出InterruptedException，从而使线程提前结束TIMED-WAITING状态。</li>
<li>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</li>
<li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止 一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以 根据 thread.isInterrupted()的值来优雅的终止线程。</li>
</ol>
<p><strong>Join</strong> ：等待其他线程终止</p>
<p>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，直到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</p>
<p><strong>notify</strong>：线程唤醒</p>
<p>Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象 上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调 用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继 续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞 争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。</p>
<p>其他方法： </p>
<ol>
<li>sleep()：强迫一个线程睡眠Ｎ毫秒。</li>
<li>isAlive()： 判断一个线程是否存活。</li>
<li>join()： 等待线程终止。 </li>
<li>activeCount()： 程序中活跃的线程数。</li>
<li>enumerate()： 枚举程序中的线程。 </li>
<li>currentThread()： 得到当前线程。 </li>
<li>isDaemon()： 一个线程是否为守护线程。</li>
<li>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线 程依赖于主线程结束而结束) </li>
<li>setName()： 为线程设置一个名称。</li>
<li>wait()： 强迫一个线程等待。</li>
<li>notify()： 通知一个线程继续运行。 </li>
<li>setPriority()： 设置一个线程的优先级。 </li>
<li>getPriority():：获得一个线程的优先级。</li>
</ol>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>假如发生某些情况时（让出CPU、时间片用完、中断），线程切换（保存当前线程上下文，留待下次占用CPU时恢复现场，加载下个占用CPU的线程上下文）。</p>
<p>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存 下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做 上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。</p>
<p>上下文 是指某一时间点 CPU 寄存器和程序计数器的内容</p>
<h2 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h2><h3 id="乐观锁（多读场景，竞争较少）："><a href="#乐观锁（多读场景，竞争较少）：" class="headerlink" title="乐观锁（多读场景，竞争较少）："></a>乐观锁（多读场景，竞争较少）：</h3><p>每次假设最好的情况，认为共享资源每次访问不会出问题，每次去拿数据的时候都认为别人不会修改，所以不会上锁，仅在修改更新的时候去会判断一下在此期间别人有没有去更新这个数 据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新）， 如果失败则要重复读-比较-写的操作。</p>
<p>不存在锁竞争，不会有死锁发生，但如果冲突频繁发生，会频繁的失败与重试，导致CPU飙升。</p>
<p>乐观锁一般会使用版本号机制或 CAS 算法实现（CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong>）。</p>
<p>乐观锁存在的问题：</p>
<p>ABA问题、循环时间长开销大、只能保证一个共享变量的循环操作</p>
<h4 id="ABA解决方法"><a href="#ABA解决方法" class="headerlink" title="ABA解决方法"></a>ABA解决方法</h4><p>ABA问题就是变量V在初次读取时值为A，准备赋值时读取仍然为A，但是这并不代表中间并没有被改变过。</p>
<p>在变量前面加上<strong>时间戳</strong>或<strong>版本号</strong></p>
<h3 id="悲观锁（多写场景，竞争激烈）："><a href="#悲观锁（多写场景，竞争激烈）：" class="headerlink" title="悲观锁（多写场景，竞争激烈）："></a>悲观锁（多写场景，竞争激烈）：</h3><p>每次假设最坏的情况，每次去拿数据的时候都认为别人 会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）</p>
<p><strong>Java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。</strong></p>
<p>激烈的锁竞争会导致频繁的系统上下文切换，造成系统的性能开销，悲观锁可能会存在死锁问题；</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁 的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋）， 等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程 也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>在 1.6 引入了适应性自旋锁，适应 性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥 有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间</p>
<h3 id="Synchronized-同步锁"><a href="#Synchronized-同步锁" class="headerlink" title="Synchronized 同步锁"></a>Synchronized 同步锁</h3><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。</p>
<h4 id="Synchronized-核心组件"><a href="#Synchronized-核心组件" class="headerlink" title="Synchronized 核心组件"></a>Synchronized 核心组件</h4><ol>
<li>Wait Set:那些调用wait方法的线程被放置在这里</li>
<li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中</li>
<li>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</li>
<li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为OnDeck</li>
<li>Owner：当前已经获取所有资源的线程被称为Owner</li>
<li>！Onwer：当前释放锁的线程</li>
</ol>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p>
<p>1、ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。 </p>
<ol start="2">
<li>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock</li>
</ol>
<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h3><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池</p>
<p>实现互斥锁（计数器为 1） 我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量， 表示两种互斥状态。</p>
<h4 id="Semaphore-与-ReentrantLock"><a href="#Semaphore-与-ReentrantLock" class="headerlink" title="Semaphore 与 ReentrantLock"></a>Semaphore 与 ReentrantLock</h4><p>Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与 release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被 Thread.interrupt()方法中断。 此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock 不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。 Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而 无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成</p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有 AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同， 区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference将一个对象的所 有操作转化成原子操作。 我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。 通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些 同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger 的性能是 ReentantLock 的好几倍。</p>
<h3 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h3><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如 果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。 </p>
<p>读锁 </p>
<p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 </p>
<p>写锁 </p>
<p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上 读锁，写的时候上写锁！ </p>
<p>ava 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现 ReentrantReadWriteLock。</p>
<h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p>
<p>独占锁 </p>
<p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。 独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<p>共享锁</p>
<p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p>
<h2 id="预防和避免死锁"><a href="#预防和避免死锁" class="headerlink" title="预防和避免死锁"></a>预防和避免死锁</h2><p>预防死锁：</p>
<p>​    破环请求与保持条件；</p>
<p>​    破环不剥夺条件；</p>
<p>​    破环循环等待条件；</p>
<p>避免死锁：</p>
<p>​    资源分配是使用-银行家算法；</p>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/377423211">https://zhuanlan.zhihu.com/p/377423211</a></p>
<h3 id="synchronized-工作原理"><a href="#synchronized-工作原理" class="headerlink" title="synchronized 工作原理"></a>synchronized 工作原理</h3><p>synchronized是一个同步关键字，在多线程场景下，作用于代码同步保护数据共享安全。</p>
<p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p>
<ol>
<li>修饰普通同步方法：锁对象就是当前实例</li>
<li>修饰静态同步方法：锁对象是当前类的Class字节码对象</li>
<li>修饰同步代码块：锁对象是synchronized后面括号里配置的对象，可以是某个对象，也可以是某个类的.class对象。</li>
</ol>
<p>JVM对于同步方法和同步代码块的处理方式不同，对于同步方法，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步，而对于同步代码块，JVM则采用 <code>monitorenter</code>（加锁）和<code>monitorexit</code> （释放锁）这两个指令实现同步。</p>
<p>Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是<code>monitorenter</code>和 <code>monitorexit</code> 指令实现的，而方法同步是通过<code>Access flags</code>后面的标识来确定该方法是否为同步方法。</p>
<p>反汇编语言中有两个<code>monitorexit</code> 是为了执行异常的<code>monitorenter</code>指令。而字节码中多出的<code>monitorexit</code>指令，就是<strong>异常结束时</strong>，<strong>被执行用来释放</strong><code>monitor</code>的。</p>
<h3 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h3><p><strong>原子性</strong></p>
<p>原子性指的是在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行。</p>
<p>如何保证：</p>
<p>Java内存模型中提供了字节码指令<code>monitorenter</code>和<code>monitorexit</code> 来隐式的使用这两个操作，在<code>synchronized</code>块之间的操作都是具备原子性的。</p>
<p><strong>可见性</strong></p>
<p> 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>如何保证：</p>
<p>通过内存屏障。内存屏障按照可见性分为：<code>load屏障</code>和<code>Store屏障</code></p>
<p><code>load屏障</code>：执行refresh，从其他处理器的高速缓存、主内存，加载数据到自己的高速缓存，保证数据的最新。</p>
<p><code>Store屏障</code>：执行flush操作，自己处理器更新的变量值，刷新到高速缓存、主内存中。</p>
<p>被<code>synchronized</code>修饰的代码，在开始执行时被加锁，执行完毕后解锁，在解锁一个变量之前，必须先把<strong>此变量同步回主存</strong>，这样解锁以后，其他线程就可以访问到被修改后的值，从而保证可见性。</p>
<p><strong>有序性</strong></p>
<p>程序执行的顺序按照代码的先后顺序执行。</p>
<p>通过内存屏障。内存屏障按照有序性分为：<code>Acquire屏障</code>和<code>Release屏障</code></p>
<p><code>Acquire屏障</code>：load屏障之后，加Acquire屏障。它会禁止同步代码块内的读操作，和外面的读写操作发生指令重排；</p>
<p><code>Release屏障</code>：禁止写操作，和外面的读写操作发生指令重排；</p>
<p>在 monitorenter 指令和 Load 屏障之后，会加一个 Acquire屏障，这个屏障的作用是禁止同步代码块里面的读操作和外面的读写操作之间发生指令重排，在 monitorexit 指令前加一个Release屏障，也是禁止同步代码块里面的写操作和外面的读写操作之间发生重排序。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
synchronize <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//monitorenter</span>
    <span class="token comment">// Load内存屏障</span>
    <span class="token comment">// Acquire屏障，禁止代码块内部的读，和外面的读写发生指令重排</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment">//注意：内部还是会发生指令重排</span>
    <span class="token comment">// Release屏障，禁止写，和外面的读写发生指令重排</span>
<span class="token punctuation">}</span> <span class="token comment">//monitorexit</span>
<span class="token comment">//Store内存屏障</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>as-if-serial，synchronized 的有序性，不是 volatile 的防止指令重排序。</p>
<p><strong>可重入性</strong></p>
<p>可重入指的就是一个线程可以多次执行synchronized，重复获取同一把锁。</p>
<h3 id="synchronized关键字可以实现什么类型的锁？"><a href="#synchronized关键字可以实现什么类型的锁？" class="headerlink" title="synchronized关键字可以实现什么类型的锁？"></a>synchronized关键字可以实现什么类型的锁？</h3><ul>
<li>悲观锁：<code>synchronized</code>关键字实现的是悲观锁，每次访问共享资源时都会上锁。</li>
<li>非公平锁：<code>synchronized</code>关键字实现的是非公平锁，即线程获取锁的顺序并不一定是按照线程阻塞的顺序。</li>
<li>可重入锁：<code>synchronized</code>关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。</li>
<li>独占锁或者排他锁：<code>synchronized</code>关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。</li>
</ul>
<h3 id="Synchronzied锁升级"><a href="#Synchronzied锁升级" class="headerlink" title="Synchronzied锁升级"></a>Synchronzied锁升级</h3><p>在jdk1.6之前，<code>synchronized</code>被称为重量级锁，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁和轻量级锁。</p>
<p>无锁-&gt;偏向锁（单线程）-&gt;轻量级锁（CAS自旋）-&gt;重量级锁（阻塞）</p>
<p><strong>为什么要进行锁优化呢</strong></p>
<p>JDK1.6之前是通过重量级锁方式去实现线程之间锁竞争的，重量级锁底层依赖操作系统的Mutex Lock来去实现互斥锁的一个功能 。Mutex是系统方法，由于权限隔离的关系，应用程序调用系统方法需要用户态切换到内核状态执行，带来性能上的损耗。</p>
<p>因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的<code>Mutex Lock</code>来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大</p>
<p><strong>引入偏向锁的目的</strong></p>
<p>减少只有一个线程执行同步代码块时的性能消耗，即在没有其他线程竞争的情况下，一个线程获得了锁。</p>
<p>偏向锁的获取流程：</p>
<ol>
<li>检查对象头中Mark Word是否为可偏向状态，如果不是则直接升级为轻量级锁。</li>
<li>如果是，判断Mark Work中的线程ID是否指向当前线程，如果是，则执行同步代码块。</li>
<li>如果不是，则进行CAS操作竞争锁，如果竞争到锁，则将Mark Work中的线程ID设为当前线程ID，执行同步代码块。</li>
<li>如果竞争失败，升级为轻量级锁。</li>
</ol>
<p>偏向锁原理：使用CAS操作将当前线程的ID记录到对象的Mark Word中。</p>
<p>引入轻量级锁的目的：在多线程交替执行同步代码块时（未发生竞争），避免使用互斥量（重量锁）带来的性能消耗。但多个线程同时进入临界区（发生竞争）则会使得轻量级锁膨胀为重量级锁。</p>
<p><strong>重量级锁的底部实现原理：Monitor</strong></p>
<p>在JDK1.6版本之后Synchronized增加锁升级的机制，来平衡数据安全性和性能的关系。简单来说，线程去访问Synchronized同步代码块的时候，Synchronized先去尝试在不加重量级锁的情况去保证线程安全性，引入了偏向锁和轻量级锁，偏向锁就是直接把当前锁偏向于某个线程，通过CAS机制来修改偏向锁的一个标记（Mark word中的线程ID改为当场线程ID），该锁适合同一线程多次去访问同一个锁资源的情况，并且没有其他线程竞争的一个场景中。轻量级锁又可以称为自旋锁，基于自适应自旋的机制，通过多次自旋去重试竞争锁（自旋次数过多就会升级到重量级锁），自旋锁的优点在于，避免了用户态到内核态切换带来的性能损耗。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic4.zhimg.com/v2-395840866ccb36a0f139903a7d5ada07_r.jpg" alt="img"></p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指Java虚拟机在即时编译时，通过对运行上下的扫描，消除那些不可能存在共享资源竞争的锁。锁消除可以节约无意义的请求锁时间。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果虚拟机检测到有一系列操作都是对某个对象反复加锁和解锁，会将加锁同步的范围粗化到整个操作序列的外部。</p>
<p>经典案例。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码会导致频繁地加锁和解锁，锁粗化后</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h3><ul>
<li><code>volatile</code>主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。<code>synchronized</code>主要是解决多个线程访问资源的同步性。</li>
<li><code>volatile</code>作用于变量，<code>synchronized</code>作用于代码块或者方法。</li>
<li><code>volatile</code>仅可以保证数据的可见性，不能保证数据的原子性。<code>synchronized</code>可以保证数据的可见性和原子性。</li>
<li><code>volatile</code>不会造成线程的阻塞，<code>synchronized</code>会造成线程的阻塞。</li>
</ul>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="volatile关键字是否保证可见性和原子性的原理"><a href="#volatile关键字是否保证可见性和原子性的原理" class="headerlink" title="volatile关键字是否保证可见性和原子性的原理"></a>volatile关键字是否保证可见性和原子性的原理</h3><p><strong>volatile</strong>关键字保证数据的可见性，无法保证数据的原子性；</p>
<p>将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取；</p>
<p><strong>volatile</strong>是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized，volatile更轻量级；</p>
<p><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序</p>
<h2 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code>实现了Lock接口，是一个可重入且独占式锁（<strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁）。和<code>synchronized</code>关键字类似，而且更强大、更灵活，增加了轮询、超时、中断、公平锁、非公平锁等功能。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230803150547162.png" alt="image-20230803150547162"></p>
<p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>
<p><code>ReentrantLock</code> 的底层就是由 AQS 来实现的。</p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p>
<p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p>
<h3 id="ReentrantLock和synchronized区别"><a href="#ReentrantLock和synchronized区别" class="headerlink" title="ReentrantLock和synchronized区别"></a>ReentrantLock和synchronized区别</h3><ul>
<li>二者都是可重入锁</li>
<li><code>ReentrantLock</code>依赖JDK（API）实现，<code>synchronized</code>依赖JVM实现</li>
<li>前者功能更加强大</li>
<li>前者实现了公平锁，后者只有非公平锁</li>
<li>前者实现了可中断锁，后者无</li>
</ul>
<p><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS就是一个抽象类，主要用来构建锁和同步器，为锁和同步器提供一些实现。</p>
<h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p>如果被请求的共享资源空闲，那么将这个请求线程作为工作线程，将共享资源设为独占资源。<strong>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制就是AQS基于CLH锁实现的。</strong></p>
<p>CLH锁：是对自旋锁的一种改进，是一个虚拟的双向队列，暂时获得不到锁的线程会加入到该队列中。</p>
<h4 id="AQS两种资源共享方式"><a href="#AQS两种资源共享方式" class="headerlink" title="AQS两种资源共享方式"></a>AQS两种资源共享方式</h4><ol>
<li><code>Exclusive</code>。（独占，只有一个线程能执行，如<code>ReentrantLock</code>）</li>
<li><code>Share</code>。（共享，多个线程同时执行，如<code>Semaphore/CountDownLatch</code>）</li>
</ol>
<p>同时实现两种资源共享方式的，如<code>ReentrantReadWriteLock</code>。</p>
<h4 id="基于AQS的常见同步类"><a href="#基于AQS的常见同步类" class="headerlink" title="基于AQS的常见同步类"></a>基于AQS的常见同步类</h4><p><strong>Semaphore（信号量）</strong></p>
<p><code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<p><strong>CountDownLatch （倒计时器）</strong></p>
<p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p><strong>CyclicBarrier(循环栅栏)</strong></p>
<p>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://javaguide.cn/assets/1-af0577dc.png" alt="img"></p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ol>
<li>继承Thread类：自己的类没有继承类就可以通过继承Thread类创建线程，Thread类本质上是实现了Runnable接口的一个实例。启动线程的唯一方法是通过Thread类的start（）方法，start（）方法是一个native方法，它启动线程并执行run（）方法。</li>
<li>实现Runnable接口：当自己的类已经继承了另一个类，就无法直接继承Thread类，此时可以通过实现Runnable接口方式创建线程。首先先需要实例化Thread，将自己的MyThread实例传入</li>
<li>实现Callable接口：<strong>有返回值的任务必须实现Callable接口，并可以抛出异常，无返回值的任务必须实现Runnable接口</strong>。执行Callable任务后可以获得一个Future对象，该对象上调用get就可以得到Callable任务返回的Object，再结合线程池接口ExecutorService就可以实现有返回结果的多线程。</li>
<li>线程池方式创建：为了避免重复创建销毁，采用此方式。Java提供了构建线程池的方式（Executors类）</li>
</ol>
<p>注：继承Thread实际上就是实现Runable，</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ol>
<li><strong>通过<code>ThreadPoolExecutor</code>构造函数创建</strong>（推荐手动创建线程池）</li>
<li><strong>通过<code>Executor</code>框架的工具类<code>Executors</code>来创建</strong>（规范中不推荐这种方式去创建线程池，因为这种方式对线程的控制粒度比较低，导致OOM）</li>
</ol>
<h4 id="JDK基于Executors提供的5种线程池"><a href="#JDK基于Executors提供的5种线程池" class="headerlink" title="JDK基于Executors提供的5种线程池"></a>JDK基于Executors提供的5种线程池</h4><ul>
<li><code>newSingleThreadExecutor</code>：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。（单例线程池）</li>
<li><code>newFixedThreadPool</code>：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。（定长线程池） </li>
<li><code>newCachedThreadPool</code>：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 （缓存线程池，没有核心线程）</li>
<li><code>newWorkStealingPool</code>：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。（工作窃取线程池）</li>
<li><code>newScheduleThreadPool</code>：（定时任务线程池，每个线程都有自己的阻塞队列，当自己的阻塞队列满了时，会去其他线程的阻塞队列窃取）</li>
</ul>
<h3 id="线程池的七个参数"><a href="#线程池的七个参数" class="headerlink" title="线程池的七个参数"></a>线程池的七个参数</h3><p>手动创建线程池，要对线程池的七个参数有所了解</p>
<p><code>corePoolSize</code>：核心线程数</p>
<p><code>maximumPoolSize</code>：最大线程数</p>
<p><code>keepAliveTime</code>：最大空闲时间</p>
<p>空闲时间内没有新任务，此 线程资源会释放</p>
<p><code>unit</code>： 时间单位</p>
<p>空闲时间单位，如秒、毫秒等</p>
<p><code>workQueue</code>：阻塞队列</p>
<p>当核心线程都在运行时，来任务就加入到其中</p>
<p><code>ThreadFactoty</code>：线程工厂</p>
<p>给线程指定名称，当线程出现问题时，可以直接锁定发生位置</p>
<p><code>handler</code> ：拒绝策略：</p>
<p>当所有线程都在繁忙，workQueue 也放满时，会触发拒绝 策略</p>
<h3 id="核心参数该如何设置"><a href="#核心参数该如何设置" class="headerlink" title="核心参数该如何设置"></a>核心参数该如何设置</h3><h3 id="线程池的饱和（拒绝）策略"><a href="#线程池的饱和（拒绝）策略" class="headerlink" title="线程池的饱和（拒绝）策略"></a>线程池的饱和（拒绝）策略</h3><ol>
<li><p>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</p>
</li>
<li><p>CallerRunsPolicy：只用调用者所在的线程来处理任务 </p>
</li>
<li><p>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务 </p>
</li>
<li><p>DiscardPolicy：直接丢弃任务，也不抛出异常</p>
</li>
</ol>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>线程池的核心属性就是ctl，基于ctl拿到<strong>线程池的状态</strong>以及<strong>工作线程的个数</strong></p>
<p>ctl实际上是一个32位的int类型，高三位为线程池状态，低29位是工作线程个数</p>
<p>五个状态：</p>
<p>111：RUNNING状态，RUNNING 可以处理任务，并且处理阻塞队列中的任务</p>
<p>000：SHUTDOWN状态，不会接收新任务，正在处理的任务正常进行，阻塞队列的任务也会做完</p>
<p>001：STOP状态，不会接受新任务，正在处理任务的线程会被中断，阻塞队列的任务一个不管</p>
<p>010：TIDYING状态，这个状态是SHUTDOWN或者STOP转换过来的，代表当前线程池马上关闭，就是过渡状态</p>
<p>011：TERMINATED状态，这个状态是TIDYING状态转换过来的，转换过来只需要执行一个terminated方法。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230821203650414.png" alt="image-20230821203650414"></p>
<p>其中正在处理任务的线程会被中断，不一定保证中断，看任务逻辑中是否有线程中断标记位的出口，有则中断</p>
<h3 id="线程池为何要构建空任务的非核心线程"><a href="#线程池为何要构建空任务的非核心线程" class="headerlink" title="线程池为何要构建空任务的非核心线程"></a>线程池为何要构建空任务的非核心线程</h3><p>核心线程为0，阻塞队列有任务，导致任务饥饿</p>
<p>导致这种情况发生有两种：</p>
<ol>
<li>创建线程池时设置核心线程数量为0</li>
<li>核心线程默认是不可以超时的，但是可以修改属性<code>allowCoreThreadTimeOut</code>为true，可以超时</li>
</ol>
<h3 id="线程池处理任务流程"><a href="#线程池处理任务流程" class="headerlink" title="线程池处理任务流程"></a>线程池处理任务流程</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20230803161712295.png" alt="image-20230803161712295"></p>
<ol>
<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ol>
<h3 id="线程池核线程数配置"><a href="#线程池核线程数配置" class="headerlink" title="线程池核线程数配置"></a>线程池核线程数配置</h3><p>分为<strong>CPU密集型</strong>和<strong>IO密集型</strong></p>
<p>CPU密集型： N（CPU 核心数）+1</p>
<p>IO密集型：CPU核心数量*2。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h2><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。</p>
<p>核心思想是<strong>异步调用，主要用在多线程领域</strong>，并非 Java 语言独有。</p>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Java5引进的，通过<code>Executor</code>来启动线程比<code>Thread</code>的<code>start</code>方法更好。更易管理，效率更好（用线程池实现），关键：有助于避免this逃避问题。</p>
<p>this逃避问题：指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
<p>Executor框架组成：</p>
<ol>
<li><strong>任务</strong>：实现Runable和callable接口</li>
<li><strong>任务的执行</strong>：Executor</li>
<li><strong>异步计算的结果</strong>：Future</li>
</ol>
<h2 id="Java常见并发容器"><a href="#Java常见并发容器" class="headerlink" title="Java常见并发容器"></a>Java常见并发容器</h2><p><code>ConcurrentHashMap</code>：线程安全的 <code>HashMap</code>。</p>
<p><strong><code>CopyOnWriteArrayList</code></strong> : 线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</p>
<p><strong><code>ConcurrentLinkedQueue</code></strong>: 高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</p>
<p><strong><code>BlockingQueue</code></strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</p>
<p><strong><code>ConcurrentSkipListMap</code></strong>: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小陈</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tangtangchen.github.io/posts/5.html">https://tangtangchen.github.io/posts/5.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tangtangchen.github.io" target="_blank">C</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%83%B3%E6%B3%95/">想法</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/reward/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/reward/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/reward/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/3.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java集合</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1.html" title="博客诞生"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-24</div><div class="title">博客诞生</div></div></a></div><div><a href="/posts/3.html" title="Java集合"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">Java集合</div></div></a></div><div><a href="/posts/2.html" title="Java基础"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-06</div><div class="title">Java基础</div></div></a></div><div><a href="/posts/4.html" title="线程池"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-26</div><div class="title">线程池</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/24/xR9pLj.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小陈</div><div class="author-info__description">博客因兴趣诞生,在不断完善中</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://tangtangchen.github.io/"><i class="fab fa-home"></i><span>个人主页</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tangtangchen/tangtangchen.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=857535276&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">兴趣爱好才是最大的动力，何不与我共同来攀知识高峰，品翘楚美人！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">Java并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">并发编程的三个基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B7%9F%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">线程跟进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">线程私有</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">程序计数器为什么是私有的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">虚拟机栈和本地方法栈为什么是私有的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">使用多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">线程的生命周期和六种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">终止线程4种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E4%B8%8E-wait-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.6.</span> <span class="toc-text">sleep 与 wait 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.7.</span> <span class="toc-text">线程基本方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.2.8.</span> <span class="toc-text">线程上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%94%81"><span class="toc-number">1.3.</span> <span class="toc-text">Java锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88%E5%A4%9A%E8%AF%BB%E5%9C%BA%E6%99%AF%EF%BC%8C%E7%AB%9E%E4%BA%89%E8%BE%83%E5%B0%91%EF%BC%89%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">乐观锁（多读场景，竞争较少）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">ABA解决方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88%E5%A4%9A%E5%86%99%E5%9C%BA%E6%99%AF%EF%BC%8C%E7%AB%9E%E4%BA%89%E6%BF%80%E7%83%88%EF%BC%89%EF%BC%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">悲观锁（多写场景，竞争激烈）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E5%90%8C%E6%AD%A5%E9%94%81"><span class="toc-number">1.3.4.</span> <span class="toc-text">Synchronized 同步锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Synchronized 核心组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">1.3.5.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.3.6.</span> <span class="toc-text">Semaphore 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore-%E4%B8%8E-ReentrantLock"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">Semaphore 与 ReentrantLock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">1.3.7.</span> <span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadWriteLock-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.3.8.</span> <span class="toc-text">ReadWriteLock 读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">1.3.9.</span> <span class="toc-text">共享锁和独占锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E9%94%81"><span class="toc-number">1.3.10.</span> <span class="toc-text">分段锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.4.</span> <span class="toc-text">预防和避免死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.5.</span> <span class="toc-text">synchronized 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">synchronized 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.2.</span> <span class="toc-text">synchronized特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">synchronized关键字可以实现什么类型的锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronzied%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">1.5.4.</span> <span class="toc-text">Synchronzied锁升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">1.5.5.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">1.5.6.</span> <span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.7.</span> <span class="toc-text">synchronized和volatile的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.6.</span> <span class="toc-text">volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E5%90%A6%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">volatile关键字是否保证可见性和原子性的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock-1"><span class="toc-number">1.7.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.7.1.</span> <span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E5%92%8Csynchronized%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.2.</span> <span class="toc-text">ReentrantLock和synchronized区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">1.8.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.1.</span> <span class="toc-text">AQS原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E4%B8%A4%E7%A7%8D%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">AQS两种资源共享方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAQS%E7%9A%84%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E7%B1%BB"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">基于AQS的常见同步类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">1.9.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.11.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.11.1.</span> <span class="toc-text">创建线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E5%9F%BA%E4%BA%8EExecutors%E6%8F%90%E4%BE%9B%E7%9A%845%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">JDK基于Executors提供的5种线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.11.2.</span> <span class="toc-text">线程池的七个参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.11.3.</span> <span class="toc-text">核心参数该如何设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%A5%B1%E5%92%8C%EF%BC%88%E6%8B%92%E7%BB%9D%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">1.11.4.</span> <span class="toc-text">线程池的饱和（拒绝）策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">1.11.5.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BA%E4%BD%95%E8%A6%81%E6%9E%84%E5%BB%BA%E7%A9%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%9D%9E%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.11.6.</span> <span class="toc-text">线程池为何要构建空任务的非核心线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.11.7.</span> <span class="toc-text">线程池处理任务流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">1.11.8.</span> <span class="toc-text">线程池核线程数配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.9.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Future%E7%B1%BB"><span class="toc-number">1.12.</span> <span class="toc-text">Future类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Executor%E6%A1%86%E6%9E%B6"><span class="toc-number">1.13.</span> <span class="toc-text">Executor框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">1.14.</span> <span class="toc-text">Java常见并发容器</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/5.html" title="并发编程"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="并发编程"/></a><div class="content"><a class="title" href="/posts/5.html" title="并发编程">并发编程</a><time datetime="2022-12-24T13:00:00.000Z" title="发表于 2022-12-24 21:00:00">2022-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3.html" title="Java集合"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="Java集合"/></a><div class="content"><a class="title" href="/posts/3.html" title="Java集合">Java集合</a><time datetime="2022-12-02T13:00:00.000Z" title="发表于 2022-12-02 21:00:00">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2.html" title="Java基础"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="Java基础"/></a><div class="content"><a class="title" href="/posts/2.html" title="Java基础">Java基础</a><time datetime="2022-11-06T13:00:00.000Z" title="发表于 2022-11-06 21:00:00">2022-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4.html" title="线程池"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="线程池"/></a><div class="content"><a class="title" href="/posts/4.html" title="线程池">线程池</a><time datetime="2022-10-26T06:00:00.000Z" title="发表于 2022-10-26 14:00:00">2022-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1.html" title="博客诞生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/imgg/1.webp" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="博客诞生"/></a><div class="content"><a class="title" href="/posts/1.html" title="博客诞生">博客诞生</a><time datetime="2022-10-24T13:00:00.000Z" title="发表于 2022-10-24 21:00:00">2022-10-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 小陈</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'U4Lu5smnaTzAKEhleB1YSBMl-MdYXbMMI',
      appKey: 'tB4abZsayiM5lM8leznvSPYC',
      placeholder: '畅所欲言！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'u4lu5smn.api.lncldglobal.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://tangtangchen.github.io/posts/5.html'
    this.page.identifier = 'posts/5.html'
    this.page.title = '并发编程'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://chen.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer id="dsq-count-scr" src="//xianqi.disqus.com/count.js" async></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/js/sakura.js"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/js/animate.js"></script><div class="aplayer no-destroy" data-id="2420480947" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="auto" data-autoplay="ture" muted></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>window.$crisp = [];
window.CRISP_WEBSITE_ID = "efdd71c0-588a-467a-925a-8c366f4b1480";
(function () {
  d = document;
  s = d.createElement("script");
  s.src = "https://client.crisp.chat/l.js";
  s.async = 1;
  d.getElementsByTagName("head")[0].appendChild(s);
})();
$crisp.push(["safe", true])

if (false) {
  $crisp.push(["do", "chat:hide"])
  $crisp.push(["on", "chat:closed", function() {
    $crisp.push(["do", "chat:hide"])
  }])
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])

    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      $crisp.push(["do", "chat:hide"])
    }
    function chatBtnShow () {
      $crisp.push(["do", "chat:show"])
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>